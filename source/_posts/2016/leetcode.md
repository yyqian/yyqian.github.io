---
title: LeetCode 解题思路汇总
date: 2016-06-16 23:33:33
permalink: 1466091213000
tags:
---

最近在用零碎的时间做做 LeetCode，锻炼下算法功底，这里把做过的题目的解题思路汇总一下。

**202.	Happy Number**

这个题目难点在于寻找闭环，有三个解法：

1. 用链表的 runner 和 walker 方法来寻找闭环
2. 用一个 set 来记录出现过的数字，如果有重复的就说明有闭环
3. 如果有闭环，则闭环中必定有 4（证明方法未知），根据这点来判定

**350.	Intersection of Two Arrays II**

解法一：

1. 先把两个数组各自排序
2. 用两个指针指向两个数组当前比较的位置，根据比较结果来移动指针和添加交叉值

解法二：

1. 用 hashtable 来记录数组 1 中每个数字出现的次数
2. 遍历数组 2，如果 hashtable 中存在当前元素就添加该元素，同时将哈希表中该元素的出现次数减一

**349. Intersection of Two Arrays**

解法一：用两个 set，数组 1 转换成 set，结果用 set 作为数据结构。然后遍历数组 2 进行比较，如果符合则加入结果的 set

解法二：跟 350 题的解法一类似，不同点是结果用 set 来作为数据结构

**231. Power of Two**

解法一：用 n & (n-1) trick

解法二：数一下 bit 为 1 的数目，符合的只会有 1 个

**326. Power of Three**

解法一：递归地检查余数，然后除以 3

解法二：3^19 = 1162261467 是 int 所能容纳的最大的符合条件的数，用它来进行取模操作。

**342. Power of Four**

326 的解法二在这行不通，因为 4 不是素数。

Power of Four 的特点是 bit = 1 的位置出现在奇数位，我们用以下步骤：

1. 先用 n & (n-1) trick 检查是否是 Power of Two
2. 然后检查 1 出现的奇偶位：检查 0b010101...010101 (也就是 0x55555555) & num 的结果是否为 0
