---
title: JVM 虚拟机执行子系统
---

本系列文章的知识来源于周志明的《深入理解 Java 虚拟机》一书，内容经过了自己的加工整理和删减。

## 6. 类文件结构

---

### 6.2 字节码

Java 中正常编译后生产的不是「二进制本地机器码（Native Code）」，而是「字节码（ByteCode）」。

JVM 有两种「无关性」：

1. 平台无关性：Java 诞生的时候有个著名的宣传口号「Write Once，Run Anywhere」，字节码是平台无关性的基石，VM 可以在不同平台上载入同一种平台无关的字节码。
2. 语言无关性：Clojure、Scala、Groovy 等语言在 javac 编译后都是生产 Class 文件。

Java 语言各个元素的语义最终都是由多条字节码组合而成的，因此字节码命令所能提供的语义描述能力比 Java 更强大，
其他语言也能实现一些有别于 Java 的语言特性。

### 6.3 Class 类文件的结构

Class 文件是一组以字节为基础单位的二进制流。（1 Byte = 8 bits），Class 文件中只有两种数据类型：无符号数和表。

无符号数有 u1、u2、u4、u8（分别代表 1 个字节、2 个字节、4 个字节、8 个字节）。无符号数可以用来描述数字、索引引用、数量值或者 UTF-8 编码的字符串值。

表是由无符号数或者其他表作为数据元构成的复合数据类型，名称以「_info」结尾。表用于描述有层次关系的复合结构的数据。

Class 文件结构中的数据项是按照严格的顺序和长度排列的，以下是部分数据项：

#### Magic Number（魔数）

u4 类型，这个值是固定的「0xCAFEBABE」，用来表明这是个 Class 文件

#### 文件版本

第 5、6 字节是 Minor Version，第 7、8 字节是 Major Version，两个 Version 都是 u2 类型

#### 常量池容量计数值

u2 类型，偏移地址 0x00000008

#### 常量池（Constant Pool）

表结构，主要存放字面量（Literal）和符号引用（Symbolic Reference）

符号引用包括了三类常量：

1. 类和接口的全限定名
2. 字段的名称和描述符
3. 方法的名称和描述符

javac 编译没有「连接」的步骤，而是在 VM 加载 Class 文件时进行动态连接的，因此其中的符号引用要在运行期才能转换得到真正的内存地址。

常量池中每一项常量都是一个表，有十四种结构不同的表，它们共同点是表开始的位置是一个 u1 类型的标志位（tag），用来表明这个常量是哪种类型（例如：UTF-8 字符串、Integer 字面量、Float 字面量、Class 符号引用、Fieldref 符号引用、Methodref 符号引用）。

例如，CONSTANT_Class_info 常量的表结构：

1. tag，u1 类型
2. name_index，u2 类型，它是一个索引值，指向常量池中一个 CONSTANT_Utf8_info 常量，代表这个类的全限定名

CONSTANT_Utf8_info 常量的表结构：

1. tag，u1 类型
2. length，u2 类型，表示存储字符串的长度
3. bytes，长度为 length，实际存储的字符串

可以用 `javap -verbose` 分析 Class 文件的字节码

#### 访问标志(Access Flag)

u2 类型，十六个可用，但当前只定义了八个：

1. ACC_PUBLIC，public 类型
2. ACC_FINAL，final 类型，只可用于 Class
3. ACC_SUPER
4. ACC_INTERFACE，接口
5. ACC_ABSTRACT，abstract 类型
6. ACC_SYNTHETIC
7. ACC_ANNOTATION，注解
8. ACC_ENUM，枚举

#### 类索引、父类索引和接口索引集合

类的继承关系就是由这三类数据来确定的：

1. this_class，u2 类型，类索引，指向一个 CONSTANT_Class_info 常量，用于确定类的全限定名
2. super_class，u2 类型，父类索引，指向一个 CONSTANT_Class_info 常量，由于 Java 不允许多重继承，因此父类索引只有一个，除了 Object 之外，父类索引都不为 0
3. interfaces_count 和 interfaces，描述了这个 Class 实现了哪些接口

#### 字段表（field_info）集合

字段表可以包括描述一个字段的所有信息：作用域（public、private、protected）、实例变量还是类变量（static）、可变性（final）、并发可见性（volatile）、数据类型（基本类型、对象、数组）、字段名称、可否被序列化。

字段表结构：

1. u2 类型，access_flags，这个类似 Class 的访问标志
2. u2 类型，name_index，对常量池的引用，字段的名称
3. u2 类型，descriptor_index，对常量池的引用，字段和方法的描述符。描述符的作用是用来描述字段的数据类型、方法的参数列表和返回值。根据描述规则，基本数据类型以及 void 类型都用一个大写字母来表示，对象类型用字符 L 加对象的全限定名来表示。
4. u2 类型，attributes_count
5. attribute_info 类型，attributes 表

#### 方法表（method_info）集合

方法表的数据结构和字段表的结构相同。

方法里的代码不在方法表中，而在后面的属性表集合中一个名为「Code」的属性里面。

#### 属性表（attribute_info）集合

字段表、方法表都可以携带自己的属性表集合，用于描述某些场景专有的信息。

属性表结合中关键常用的有：

- Code 属性表：在方法表中使用，存储了 Java 代码编译后的字节码指令
- ConstantValue 属性表：字段表中使用，final 关键字定义的常量值
- Exceptions 属性表：方法表中使用，方法抛出的异常
- InnerClasses 属性表：类文件中使用，内部类列表
- 还有很多，见书中 page 181

对于每个属性表的表结构：

1. u2 类型，attribute_name_index
2. u4 类型，attribute_length
3. u1 类型，info，长度为 attribute_length

这里只简单分析下 Code 属性表，这个属性是 Class 文件中最重要的一个属性，如果把一个 Java 程序中的信息分为代码（方法体的 Java 代码）和元数据（包括类、字段、方法定义等），那么整个 Class 文件中，Code 属性用于描述代码，所有的其他数据项目都用于描述元数据。

Code 属性出现在方法表中，但不是必定存在的，接口或抽象类就没这个属性。属性表的结构为：

1. u2 类型，attribute_name_index
2. u4 类型，attribute_length，长度为整个属性表的长度（包括开头的 u2 + u4）
3. u2，max_stack，操作数栈深度的最大值，JVM 运行时要根据这个值来分配 Stack Frame 中的操作栈深度
4. u2，max_locals，局部变列表所需的存储空间，这里的单位是 slot，slot 是 JVM 为局部变量分配内存的最小单位，对于 byte、char、float、int、short、boolean 等长度不超过 32 位的数据类型，每个局变量占用 1 个 slot，而 double 和 long 这两种 64 位的数据类型则要两个 slot 存放。
5. u4，code_length，后面所有字节码的占据长度
6. u1，code，这里的 u1 指的是每个字节码是 u1 类型的单字节，整个的指令列表长度为 code_length
7. exception_table_length
8. exception_table，这个是显式异常处理表集合
9. attributes_count
10. attributes

javap 中输出的 Args_size 值有可能会比代码中参数列表的大小多一个，原因是任何实例方法，都会有一个 this 关键词，局部变量表会预留第一个 slot 位来存放对象实例的引用。但如果是 static 方法，就不会多一个。

### 6.4 字节码指令

JVM 采用操作数栈而不是寄存器的架构，大多数指令只有一个操作码，没有操作数。

大多数指令都包含了其操作所对应的数据类型信息。例如：iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 是加载 float 类型的，它们是两个独立的操作码。

对应关系：

- i: int
- l: long
- s: short
- b: byte
- c: char
- f: float
- d: double
- a: reference

由于操作数只能是一个字节，所以可以用的数量有限，JVM 的指令集对于特定的操作，只提供了有限的类型相关指令去实现它。譬如：Tadd 只实现了 iadd、ladd、fadd、dadd。大多数对于 boolean、byte、short 和 char 类型数据的操作，都是使用 int 类型的操作来实现的。

指令集的表见 page 199

加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输：

- Tload：将一个局部变量加载到操作数栈
- Tstore：将一个数值从操作数栈存储到局部变量表
- 还有一系列将一个常亮加载到操作数栈

运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。

其他还有类型转换、对象创建和访问、操作数栈管理（出栈、复制栈顶、栈最顶端两个数值互换）、控制转移（if、switch、goto）、方法调用和返回、异常处理、同步指令。

方法调用和返回指令有：

- invokevirtual：调用对象的实例方法，这是最常见的方式
- invokeinterface：调用接口方法，它会在运行时搜索实现了这个接口的方法
- invokespecial：调用需要特殊处理的实例方法，譬如实例初始化方法、私有方法和父类方法
- invokestatic：调用类方法（static 方法）
- invokedynamic：这一条指令是 JDK 1.7 新加的，可以实现一些动态的特性，调用非 Java 语言

JVM 实现同步有两种方式，都是使用管程（Monitor）来支持的：

- 方法级的同步：通过 ACC_SYNCHRONIZED 访问标志来判断是否为同步方法，如果是，则先成功持有管程，然后方法完成后再释放管程。这种方式是隐式的，即无须通过字节码指令来控制。
- 方法内部的 synchronized 语句块来实现同步：JVM 指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键词的语义。

### 6.5 公有设计和私有实现

JVM 规范描绘了 JVM 应有的共同的存储格式：Class 文件格式和字节码指令集。JVM 必须能够读取并精确实现其中的语义。

但是实现的方式是宽松的，目的是更高的性能、更低的内存消耗和更好的移植性，实现方式有两种：

1. 将输入的字节码在加载或运行时翻译成另外一种 VM 的指令集
2. 将输入的字节码在加载或运行时翻译成本地机器码（即 JIT 编译器）

## 7. 虚拟机类加载机制

---

虚拟机的类加载机制：VM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 VM 直接使用的 Java 类型。

Java 里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 有高度的灵活性。Java 可以动态扩展的特性就是依赖于运行期动态加载和动态连接这个特点实现的。JSP、OSGi技术都使用了 Java 运行期类加载的特性。

### 7.2 类加载的时机

类的生命周期：

![](http://cdn.yyqian.com/1455864579129_a.jpg)

类的解析可以在初始化阶段之后再开始，目的是支持 late-binding。

JVM 规范了有且只有五种情况必须立即对类进行「初始化」（加载、验证、准备当然要在这之前）：

1. 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令，如果类没有初始化，则先触发其初始化。生成这四条指令的场景场景：使用 new 实例化对象、读取或设置类的静态字段（final 修饰的会在编译期就把结果放入常量池的静态字段）、调用一个类的静态方法。
2. 使用 java.lang.reflect 包的方法对类进行反射调用
3. 初始化一个类的时候，发现父类还没有经过初始化，则需要先触发父类的初始化
4. JVM 启动的时候，要先初始化包含 main() 方法的要执行的主类
5. JDK 1.7 新出来的对动态语言的支持

这五种场景的行为称为对类进行「主动引用」。除此之外还有「被动引用」：

1. 通过子类引用父类的静态字段，只会初始化父类，不会初始化子类
2. 通过数组定义来引用类，不会触发此类的初始化。例如：SomeClass[] sca = new SomeClass[10];
3. 调用被 final 修饰的静态常量，这个常量在编译期就会存入调用类的常量池中，因此本质上没有直接引用到类，因此不会触发类的初始化

### 7.3 类加载的过程

#### 加载

这里的「加载」指的是类加载（Class Loading）过程的一个阶段，在加载阶段，有三个步骤：

1. 通过类的全限定名来获取此类的二进制字节流。这个二进制字节流的获取来源是多样的，譬如 zip 包（JAR、WAR）、网络、运行时计算生成
2. 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

但是，数组类不是通过类加载器创建的，它是由 JVM 直接创建的。但是数组类的元素类型是要靠类加载器去创建的。

#### 验证

JVM 对字节码的验证是对 VM 自身的一个保护，来承受恶意代码的攻击，验证阶段分为四个动作：

1. 文件格式验证
2. 元数据验证：例如类是否有父类、是否实现了父类或接口中要实现的方法等
3. 字节码验证：这个动作是验证过程最复杂的，要通过数据流和控制流分析，确定程序语义是否合法、符合逻辑。
4. 符号引用验证：例如通过全限定名是否能找到对应的类、符号引用中的类、字段、方法的访问性是否可被当前类访问

验证阶段是一个重要、但不是必要的，如果全部代码都被反复使用和验证过，可以在实施阶段关闭类验证，以缩短 VM 类加载的时间。

#### 准备

准备阶段是为类变量分配内存并设置类变量初始值的阶段，分配的内存都在方法区。这里的初始值是指「零值」，假设类变量的定义是：

```
public static int value = 123;
```

那么在准备阶段之后，value 的初始值是 0 而不是 123。因为这个时候还没执行任何 Java 方法，赋值 123 的 putstatic 指令是在程序被编译后，存在类构造器`<clinit>()` 方法中的。但是，如果被 final 修饰过：

```
public static final int value = 123;
```

则准备阶段之后，初始值就会变成 123。

强调的是，类变量只有是被 static 修饰的变量，不包括实例变量，实例变量将在对象实例化时随对象分配在 Heap 中。

#### 解析

解析阶段是 VM 将常量池内的符号引用替换为直接引用的过程。

- 符号引用（Symbolic References）用一组符号来描述所引用的目标，符号可以是任意形式的字面量。符号引用的目标不一定已经加载到内存中。
- 直接引用（Direct References）可以是直接指向目标的指针、相对偏移量或间接定位到目标的句柄。如果有直接引用，那么引用的目标必定已经在内存中存在。

#### 初始化

前面的阶段都是由 JVM 主导和控制的。到了初始化阶段，才真正开始执行类中定义的 Java 代码（或者说是字节码）。

初始化阶段是执行类构造器 `<clinit>()` 方法的过程。这个阶段是可以由程序员代码控制的。

`<clinit>()` 方法是由编译器收集类中的所有类变量赋值动作和静态语句块（`static{}` 块）合并产生的。执行的顺序是按照代码中出现顺序。

`<clinit>()` 方法与类的构造函数（实例构造器 `<init>()` 方法）不同，它不需要显式地调用父类构造器，VM 能保证父类的 `<clinit>()` 方法先执行，因此 java.lang.Object 的类构造函数肯定是第一个被执行的。

`<clinit>()` 方法对类和接口都不是必须的，如果没有 `static{}` 语句块和静态变量初始化赋值，就没有 `<clinit>()` 方法。

JVM 会保证 `<clinit>()` 方法的线程安全，会对这个初始化过程进行加锁、同步。当然这个过程也是阻塞的，但是阻塞之后其他进程也不会再次进入这个方法，因为同一个类加载器，一个类只会初始化一次。

### 7.4 类加载器

前面类加载过程中的「加载」阶段，有个动作是「通过类的全限定名来获取此类的二进制字节流」，实现这个动作的代码模块称为「类加载器」。

一个类是由类本身和加载它的类加载器两者来确定唯一性的。如果两个类来源于同一个 Class 文件，被同一个虚拟机加载，但加载他们的类加载器不同，则这两个类是「不相等」 的。

这里的「相等」指的是 Class 对象的 equals()、instanceof 关键词判断的结果。

从 JVM 的角度来讲，只有两类加载器：

1. 启动类加载器（Bootstrap ClassLoader），用 C++ 实现，是 JVM 自身的一部分

2. 所有其他的类加载器，由 Java 实现，独立于 VM 外部，并且全部继承自抽象类 java.lang.ClassLoader

我们的应用程序一般由三类加载器进行加载：

- Bootstrap ClassLoader 负责将 `<JAVA_HOME>\lib` 目录中的类库加载到虚拟机的内存中。

- Extension ClassLoader 负责将 `<JAVA_HOME>\lib\ext` 目录中的类库加载，由 Java 实现，开发者可以直接使用。

- Application ClassLoader 负责加载用户 ClassPath 上所指定的类库，由 Java 实现，开发者可以直接使用。

这些类加载器，包括额外的类加载器，普遍采用一种「双亲委派模型」来实现层次关系。

这个是 Tomcat 的类加载器模型：

![](http://cdn.yyqian.com/1455864579129_b.jpg)

「双亲委派模型」的工作过程大致是：如果一个类加载器收到类加载请求，它首先不自己加载，而是将这个请求委托给父类加载器，然后一层层往上传，直到顶层的 Bootstrap ClassLoader，如果父类 ClassLoader 反馈无法完成加载，然后再一层层往下尝试，直到尝试成功。这个模型主要是解决基础类统一的问题，如果没有这种机制，类似 Object 的类就会由不同的加载器重复加载，但彼此又「不相等」。

「双亲委派模型」存在一个缺陷：基础类无法调用回用户的代码，JNDI 服务可以解决这个问题。

类加载器方面，还有 OSGi 技术实现的 Java 模块化，以及发展中的 Jigsaw 项目。

## 8. 虚拟机字节码执行引擎

---

这章主要是讲虚拟机字节码执行引擎的「概念模型」，这个概念模型成为各种 JVM 的统一外观（Facade）。所谓统一外观，只的是输入输出是相同的（输入是字节码、输出是执行结果），但中间实际的执行过程是可以由 JVM 自行优化的，只需要保证一种「等效性」。JVM 的执行引擎可能会解释执行（通过解释器）、编译执行（通过 JIT 编译器生成本地代码执行）或者两者兼备。所以这里的「概念模型」不是 JVM 实际实现的模型，而是一种 JVM 标准规范的「等效模型」。

### 8.2 运行时栈帧结构

栈帧（Stack Frame）是虚拟机栈（VM Stack）的栈元素，用于支持 VM 进行方法调用和方法执行的数据结构。其中存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。

前面说到的 Code 属性定义了最大的局部变量表大小，最深的操作数栈，因此运行时就可以按照这个数值为栈帧分配内存。

一个线程中的方法调用链可能很长，很多方法都同事处于执行状态，但只有栈顶的栈帧才是有效的，称为「当前栈帧」，该栈帧中的方法称为「当前方法」，执行引擎运行的所有字节码都只对当前栈帧进行操作。

#### 局部变量表

局部变量表的最大容量的确定在：Class 文件 - 属性表（attribute_info）集合 - Code 属性表 - max_locals 数据项。

局部变量表的容量以变量槽（Variable Slot，Slot）为最小单位。boolean、byte、char、short、int、float、reference 或 returnAddress 类型的数据可以用一个 slot 来存储，long 和 double 要用两个 slot 来存储。虽然一个 64 位的数据分割成两个 slot 来操作违反原子性，但是局部变量表是在 Stack 中的，Stack 是封闭在线程内的，所以仍然是线程安全的。

局部变量表中的索引 n 就代表使用了第 n 个 slot。第 0 位索引的 slot 默认是用于传递 this 对象的。表中的数据是可以复用的，当一个变量超出了其作用域，新的变量就能重复使用旧变量占据的 slot。

要注意的是局部变量不像类变量存在「准备阶段」，也就没有初始化零值的动作，所以局部变量是没有默认的初始值的。实际上不初始化就使用的话，编译也是通不过的。

#### 操作数栈

操作数栈（Operand Stack）是一个 LIFO 栈，栈的最大深度在 Code 属性表的 max_stacks 数据项中确定。32 位数据占的栈容量为 1，64 位的为 2。

方法执行的过程，会有各种字节码指令往操作数栈中写入和提取内容，也就是入栈、出栈的过程。操作数栈中的元素要与字节码指令处理的类型一致，譬如：iadd 指令不能用于 long 和 float 数据。

#### 动态连接

Class 文件中的符号引用最终是需要转化成直接引用的，有两种情况：

1. 静态解析：在类加载阶段或者第一次使用的时候就转化为直接引用
2. 动态连接：每一次运行期间都转化为直接引用

#### 方法返回地址

一个方法的退出有两种方法：

1. VM 遇到任意一个方法返回的字节码指令，这时候有可能有返回值传递给方法调用者，这种退出方式称为正常完成出口
2. 另外一种方式是方法执行过程中遇到了异常，并且方法体没有捕获处理这个异常，这种称为异常完成出口

方法退出的过程实际上等同于当前栈帧出栈，此时可能的操作有：

- 恢复上层方法的局部变量表和操作数栈
- 把返回值压入调用者栈帧的操作数栈中
- 调整 PC 计数器的值以指向方法调用后面的一条指令

### 8.3 方法调用

一切方法调用在 Class 文件里存储的都只是符号引用，而不是直接引用（因为在编译阶段不会进行连接）。目标方法的直接引用要到类加载，甚至运行时才能获得。

#### 解析

只有满足「编译器可知，运行期不可变」的要求，才能在类加载阶段，就将符号引用转化为直接引用，满足这个条件的主要包括静态方法和私有方法两大类。JVM 中有五种方法调用的字节码指令：

- invokestatic：调用类方法（static 方法）
- invokespecial：调用需要特殊处理的实例方法，譬如实例初始化方法、私有方法和父类方法
- invokevirtual：调用所有的虚方法
- invokeinterface：调用接口方法，它会在运行时搜索实现了这个接口的方法
- invokedynamic：这一条指令是 JDK 1.7 新加的，可以实现一些动态的特性，调用非 Java 语言

#### 分派（Dispatch）

面向对象有三个基本特征：集成、封装和多态。分派最主要展现了多态的特征。

这部分不太理解。

#### 动态类型语言支持

Java 的动态特性依靠 JDK 7 中的 invokedynamic 字节码指令实现。

动态类型语言的类型检查的主体过程是在运行期而不是编译期（Clojure、Erlang、JavaScript、Python 等），而编译期就进行的就是静态类型语言（C++，Java）。
「变量无类型而变量值才有类型」是动态类型语言的一个重要特征。

JVM 之前只有四条方法调用指令，这四条指令的第一个参数都是被调用方法的符号引用。方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定接收者类型，因此 JDK 7 新出了一个 invokedynamic 指令以及 java.lang.invoke 包来实现动态类型。

### 8.4 基于栈的字节码解释执行引擎

JVM 执行引擎有两种执行方式：解释执行（通过解释器，解释字节码执行）和编译执行（通过 JIT 编译器，编译产生本地代码执行）。这个小节只限定于解释执行。

Java 采用的是一种「基于栈的指令集架构」，以 `1 + 1` 为例：

```
iconst_1
iconst_1
iadd
istore_0
```

如果是基于寄存器的，则是：

```
mov eax, 1
add eax, 1
```

基于栈的优点是可移植，寄存器是由硬件直接提供，依赖硬件寄存器就会受到硬件的约束。但缺点有：

- 执行速度相对来说要慢一些
- 完成相同功能所需的指令数比寄存器架构的更多
- 栈实现在内存中，频繁的栈访问意味着频繁的内存访问，而内存的速度远低于寄存器、缓存。

通过 javap 获得的字节码执行流程只是一种「概念模型」，实际情况差距会很大，因为 JVM 的解析器和 JIT 编译器都会对字节码进行优化。

## 9. 类加载及执行子系统的案例与实战

---

前面两章的内容中，Class 文件存储的格式、类加载时间、如何连接，以及虚拟机如何执行字节码指令等都是由 VM 直接控制，开发人员无法对其进行改变。能通过程序控制的，主要是「字节码生成」与「类加载器」这两部分功能。

以下是类加载器的两个例子，字节码生成技术（javac、CGLib、ASM）见书本。

#### Tomcat：正统的「双亲委派模型」类加载器架构

Tomcat 早期版本的目录中，有：

- `/common/*`：类库可被 Tomcat 和所有 Web 应用共用
- `/server/*`：只对 Tomcat 可用
- `/shared/*`：可对所有的 Web 应用可用，Tomcat 不可用
- 程序目录下的 `/WEB-INF/*`：程序自身可用，Tomcat 和 其他 Web 应用不可见

这些隔离的需求就是通过「双亲委派模型」实现的，见前面的图。在 6.x 版本中这几个目录简化合并成一个 `/lib` 目录了，但是如果需要的话还是可以通过修改配置来重新启用原来的模型。

#### OSGi：灵活的类加载器架构

OSGi 每个模块（称为 Bundle）都类似一个类库，一般以 JAR 格式封装（存储了 Package 和 Class）。Bundle 可以声明它依赖的 Package，也可以声明它允许到处发布的 Package。

OSGi 里面，加载器之间的关系不是树形结构，而是一种复杂的、运行时才能确定的网状结构。并且这项技术有可能实现模块级的热插拔功能。

---

注：

1. 符号引用（Symbolic References）用一组符号来描述所引用的目标，符号可以是任意形式的字面量。符号引用的目标不一定已经加载到内存中。
2. 直接引用（Direct References）可以是直接指向目标的指针、相对偏移量或间接定位到目标的句柄。如果有直接引用，那么引用的目标必定已经在内存中存在。
