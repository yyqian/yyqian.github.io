---
title: SICP 笔记
date: 2015-08-25 11:06:28
permalink: 1440471988201
tags: SICP
---

看完第一章，我觉得这就是一本关于**抽象**的书。

我的习题解答见：[https://github.com/yyqian/sicp-solutions](https://github.com/yyqian/sicp-solutions)

# Chapter 1

应用序和正则序的差别：正则序先展开，再求值；应用序先求值，再代入。Lisp采用应用序求值。如果遇到if条件判断，正则序也应当立即求值。

习题1.6用函数的方式定义了一个new-if，这个和if的区别是：new-if的then-clause和else-clause都会被执行，而if则只会根据predicate判断结果执行其中一个。原因是new-if是个普通函数，并且Lisp采用应用序求值，因此then-clause和else-clause作为表达式代入的时候回先求值再代入。

迭代过程一般优于递归过程。迭代过程需要有以下几个要素：

1. 状态变量
2. 一套规则，用于描述迭代过程中从一个状态到下一个状态的转换
3. 结束检测，用于判断边界
<!-- more -->
线性递归的经典例子是n!，树形递归的经典例子是Fib(n)。

树形递归的计算复杂度正比于树的节点数，空间需求正比于树的最大深度。

Fib(n)的树形递归计算复杂度是指数的，空间需求是线性的。

Fib(n)的迭代算法：

1. 状态变量：(a, b)，这个表示(Fib(n), Fib(n-1))
2. 迭代过程的变换规则：T = ((1, 1), (1, 0))，变换之后得到新的状态：(a+b, a)，即(Fib(n+1), Fib(n))
3. 边界是n

这个迭代算法计算复杂度是O(n)，空间需求是O(1)。练习1.19有个Fib(n)加速迭代的算法，原理和求幂的加速迭代类似，利用T^2的一般形式，将原来固定的变换规则T也变成可变的状态，计算复杂度是O(log(n))。

可以用数学归纳法证明Fib(n) = (a^n - b^n)/sqrt(5)，其中a, b是x^2 - x - 1 = 0的两个根。

练习1.16, 1.17, 1.18提供了一种设计迭代算法的思路：定义一个不变量，要求在状态变换的过程中保持不变。  

以求幂的迭代过程为例：求a=b^n，我们可以定义一个cons = a(b^n)，初始化a为1，这样cons就等于b^n。这里的状态变换规则是满足a(b^n)不变。计算思路是在迭代的过程中，将b^n的值“转移”到a中，直至b^n = 1，这时a = cons = b^n。如果我们想加速迭代过程，可以让n以折半的方式快速变小。  

习题1.18采用的不变量则是cons = a * b + y，初始化y = 0，则cons = a * b，设法在迭代过程中将a * b的值“转移”到y中，直至a * b = 0，那么y = cons = a * b。

费马检查：任取一个正整数a<n，如果满足(a^n)%n === a，那么n很有可能是素数，如果不等，那么n肯定不是素数。也就是说判断不是素数是确定的，但判断是素数不是个确定的算法。能骗过费马检查的数称为Carmichael数，譬如561, 1105, 1729, 2465 ... 还有一种不会被骗的算法见练习1.28

高阶函数其实就是用函数来构造新的函数，一般会涉及到将函数当作参数来传递或返回，可以用来lambda表达时来简化书写，这里的要点是对程序进一步**抽象**，把函数也视作数据。

# Chapter 2

SICP这本书的习题我觉得是精心准备的，譬如练习2.35，读者的第一反应可能是将tree转变为list然后一个个数，但题目限定了要用map来处理tree，其实这里作者是给了个hint，更聪明的做法是用递归，然后用map把叶子映射为1，把节点用count-leaves去递归数数，然后映射为节点下的叶子数。
