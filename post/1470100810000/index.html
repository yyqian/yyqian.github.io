<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="MySQL,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0">






<meta name="description" content="索引优化是对查询性能优化最有效的手段，这篇文章就来研究下 MySQL 的索引。在介绍优化索引的方法之前，会先介绍索引是如何工作的，我们应当根据这些理解来创建最合适的索引，而不是一些经验法则。 索引类型MySQL 中不同存储引擎使用的索引不同，支持的索引的类型也不同。 B-Tree 索引InnoDB 使用的是 B+Tree，它的优点是 IO 读取次数少，适用于硬盘这种瓶颈在于 IO 的设备。B+Tr">
<meta name="keywords" content="MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 索引优化">
<meta property="og:url" content="http://yyqian.github.io/post/1470100810000/index.html">
<meta property="og:site_name" content="YYQIAN">
<meta property="og:description" content="索引优化是对查询性能优化最有效的手段，这篇文章就来研究下 MySQL 的索引。在介绍优化索引的方法之前，会先介绍索引是如何工作的，我们应当根据这些理解来创建最合适的索引，而不是一些经验法则。 索引类型MySQL 中不同存储引擎使用的索引不同，支持的索引的类型也不同。 B-Tree 索引InnoDB 使用的是 B+Tree，它的优点是 IO 读取次数少，适用于硬盘这种瓶颈在于 IO 的设备。B+Tr">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-02-11T15:15:56.235Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL 索引优化">
<meta name="twitter:description" content="索引优化是对查询性能优化最有效的手段，这篇文章就来研究下 MySQL 的索引。在介绍优化索引的方法之前，会先介绍索引是如何工作的，我们应当根据这些理解来创建最合适的索引，而不是一些经验法则。 索引类型MySQL 中不同存储引擎使用的索引不同，支持的索引的类型也不同。 B-Tree 索引InnoDB 使用的是 B+Tree，它的优点是 IO 读取次数少，适用于硬盘这种瓶颈在于 IO 的设备。B+Tr">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> MySQL 索引优化 | YYQIAN </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">YYQIAN</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Do not go gentle into that good night</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                MySQL 索引优化
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-02T09:20:10+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>索引优化是对查询性能优化最有效的手段，这篇文章就来研究下 MySQL 的索引。在介绍优化索引的方法之前，会先介绍索引是如何工作的，我们应当根据这些理解来创建最合适的索引，而不是一些经验法则。</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>MySQL 中不同存储引擎使用的索引不同，支持的索引的类型也不同。</p>
<h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h3><p>InnoDB 使用的是 B+Tree，它的优点是 IO 读取次数少，适用于硬盘这种瓶颈在于 IO 的设备。B+Tree 的非叶子节点存的是 key（不包含指向数据的指针）。我们学数据结构的时候，这个 key 一般是个整数，这样就能自然地进行排序；但实际应用中，key 不一定非得是整数，我们也还可以组合多个 key 成为一个组合的 key，这就是所谓的索引，例如某个索引可以由 last_name, first_name, date_of_birth 三个键组成。<br><a id="more"></a><br>这里需要关注的一点就是索引列的顺序，因为查询只能使用索引的最左前缀，直到遇到第一个范围条件列，不能跳过某个索引列。以索引 ABC 为例，我们可以查询：</p>
<ol>
<li>严格匹配 ABC 三个列</li>
<li>严格匹配 A</li>
<li>范围匹配 A（可以是前缀，也可以是某个取值范围）</li>
<li>严格匹配 A，范围匹配 B</li>
</ol>
<p>所以对于同样的三个索引列，有时我们可能需要 ABC, BAC, CAB 等多个不同组合顺序的索引来满足我们的查询优化。</p>
<p>除此之外，B+Tree 有个特殊的地方是索引和实际的数据是分开存储的，所以我们可以只访问索引，不访问数据，这样可以实现后面要讲的索引覆盖查询，可以大大提高查询效率。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>学数据结构的时候，我们知道实现 Map 有哈希表和搜索树两种方式（前面 B-Tree 也是一种搜索树），并且根据经验，哈希表一般要比搜索树更高效，但这些比较都是脱离了 IO 等因素来说的，也就是说，更准确的说法是只在内存中操作的话，哈希表比搜索树更高效（如果是基于硬盘，前面的 B-Tree 更高效）。由于这些原因，MySQL 中只有 Memory 引擎显示支持哈希索引。</p>
<p>哈希表中存的键是索引列的哈希值（并不是索引列本身的内容），表也是按照哈希值的顺序存储的，所以哈希索引只适用于快速的随机读取，不能按索引列的值的顺序进行排序、匹配、范围查询等顺序操作。</p>
<p>除此之外，我们可以按照这个思路在 InnoDB 等引擎中自定义哈希索引列来加快某些列的查询速度。例如 url，对 url 这种长的字符串进行匹配比较耗时，我们可以增加一个 url_crc=CRC32(url) 的列存放 url 的哈希值，查询的时候使用以下语句：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">******** WHERE <span class="attribute">url_crc</span>=CRC32("XXX") <span class="keyword">AND</span> <span class="attribute">url</span>=<span class="string">"XXX"</span>;</span><br></pre></td></tr></table></figure>
<p>url_crc 和 url 组成一个多列的哈希索引，url 主要是用来防止哈希碰撞的，进行索引选择的主要是 url_crc。</p>
<p>这种方式的实现可以使用触发器，让 url 更新或插入操作来触发哈希值的计算和设置。</p>
<h3 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h3><p>主要有空间数据索引和全文索引。空间索引做的比较好的是 PostgreSQL 的 PostGIS。全文索引让搜索引擎来做更合适，例如 ElasticSearch。</p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>索引主要有三个优点：</p>
<ol>
<li>减少需要遍历的数据量</li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机 I/O 变为顺序 I/O</li>
</ol>
<p>索引的缺点：</p>
<ol>
<li>索引占据额外的空间</li>
<li>对于非常小的表，全表遍历一般更高效，这时候就也没必要有索引。</li>
</ol>
<p>评价索引好坏的「三星系统」：</p>
<ol>
<li>索引将相关的记录放在一起</li>
<li>索引中的数据顺序和查询中的排列顺序一致</li>
<li>索引中的列包含了查询中需要的全部列</li>
</ol>
<h2 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h2><h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">索引选择性 </span>=<span class="string"> 不重复的索引值数目（Cardinality） / 记录总数</span></span><br></pre></td></tr></table></figure>
<p>例如，我们有 10 组有关年龄的数据：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">年龄, 其他列</span><br><span class="line">12, <span class="emphasis">***</span></span><br><span class="line">23, <span class="emphasis">***</span></span><br><span class="line">23, <span class="emphasis">***</span></span><br><span class="line">40, <span class="emphasis">***</span></span><br><span class="line">51, <span class="emphasis">***</span></span><br><span class="line">54, <span class="emphasis">***</span></span><br><span class="line">62, <span class="emphasis">***</span></span><br><span class="line">62, <span class="emphasis">***</span></span><br><span class="line">71, <span class="emphasis">***</span></span><br><span class="line">93, <span class="emphasis">***</span></span><br></pre></td></tr></table></figure>
<p>如果用年龄作为索引，那么以上不重复的索引的个数是 8，索引选择性就等于 0.8。</p>
<p>如果记录总数记为 T，那么索引选择性的取值范围就是 1/T 到 1 之间。1 代表没有重复的索引，这种索引选择性最高，性能也就最好。</p>
<p>对于字符串，我们经常要用前缀索引，这个时候就需要截断。如果截得太短，例如只截一个字母，那么对于英文来说不重复的索引值数目就只有 26 个，这时候索引选择性就不好（相当于很多哈希碰撞），所以我们要尝试各种截取的长度，来测试索引选择性如何，最后得到一个既保证较高选择性，又不太长的前缀索引。</p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>多列索引常见的误区是为每个列单独设立索引，例如有 A, B, C 三个列，索引 A、索引 B、索引 C 这三个不是多列索引，而是三个单独的索引；索引 AC 或索引 BAC 这种才是多列索引。</p>
<p>在当前版本的 MySQL 中，类似 <code>WHERE A=** OR B=***</code> 的查询，如果没有多列索引，只有单列索引 A 和单列索引 B，那么我们 EXPLAIN 这个查询语句之后，会发现有 union 等字样，这表明它会用这个两个单列索引，并且把它们查询结果合并。这时候我们就应该考虑用多列索引 AB 来优化这个查询。</p>
<h3 id="多列索引中的索引列的顺序"><a href="#多列索引中的索引列的顺序" class="headerlink" title="多列索引中的索引列的顺序"></a>多列索引中的索引列的顺序</h3><p>对于 <code>WHERE A=*** AND B=***</code> 这样的 SQL 语句，SQL 语句中的 A 和 B 的顺序是无所谓的，最主要的是在建立 AB 多列索引的时候，A 和 B 的先后顺序是有讲究的。</p>
<p>如果只用于优化上面的 WHERE 语句，那么应当把索引选择性高的那个列放在前面。除此之外，为满足 ORDER BY, GROUP BY, DISTINCT 等子句的查询需求，我们应当根据这些查询语句，来确定正确的索引列的顺序，来满足排序和分组的需要。</p>
<h3 id="聚簇索引（Clustered-Index）"><a href="#聚簇索引（Clustered-Index）" class="headerlink" title="聚簇索引（Clustered Index）"></a>聚簇索引（Clustered Index）</h3><p>聚簇索引是一种数据存储方式，这里只讨论 InnoDb 的实现，它的存储类似于 B-Tree。当有聚簇索引的时候，数据在物理上是按照该索引的顺序连续存储的。因此，当按照聚簇索引进行遍历的时候，系统可以一次 I/O 读取一整页的数据（包括很多行数据），这样就大大节省了 I/O 的次数。</p>
<p>用户是无法指定哪个列作为聚簇索引的。InnoDB 会根据以下优先级选择聚簇索引：</p>
<ol>
<li>PRIMARY KEY</li>
<li>被 UNIQUE 和 NOT NULL 修饰的索引</li>
<li>InnoDB 自己隐式定义的主键</li>
</ol>
<p>因此，对于大多数有主键的表，聚簇索引和主键两者是相同的。</p>
<p>聚簇索引的主要优点有：</p>
<ol>
<li>相关数据可以在物理上保存在一起</li>
<li>数据访问速度更快</li>
<li>覆盖索引扫描的查询可以直接使用页节点中的主键值</li>
</ol>
<p>缺点：</p>
<ol>
<li>聚簇索引主要是减少 I/O 的次数，这对于内存型的引擎并不重要</li>
<li>插入速度依赖于插入顺序，如果不是按照聚簇索引的顺序进行插入的，速度就会较慢。</li>
<li>更新聚簇索引列的代价很高，需要在物理上移动数据行</li>
</ol>
<h3 id="二级索引（Secondary-Index）"><a href="#二级索引（Secondary-Index）" class="headerlink" title="二级索引（Secondary Index）"></a>二级索引（Secondary Index）</h3><p>所有除了聚簇索引之外的索引都是二级索引，例如一个用户表，id 是主键，那么 id 就是聚簇索引。如果还用 name 列建了索引，那么这个就是二级索引。</p>
<p>为什么叫「二级索引」呢？因为所有的二级索引都必须包含聚簇索引，InnoDB 是通过聚簇索引来搜索指定行的。从数据结构上看，二级索引叶子节点保存的是行的主键值，而不是指向行的物理位置的指针。</p>
<p>例如索引（name），它实际包含了两列：id 和 name，我们先通过 name 找到相应的 id，再通过 id 获得相应的数据行。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">name</span>=<span class="string">"Yinyin Qian"</span> --&gt; <span class="attribute">id</span>=12 --&gt; physical_address = 0x23957204</span><br></pre></td></tr></table></figure>
<h3 id="InnoDB-和-MyISAM-的数据分布对比"><a href="#InnoDB-和-MyISAM-的数据分布对比" class="headerlink" title="InnoDB 和 MyISAM 的数据分布对比"></a>InnoDB 和 MyISAM 的数据分布对比</h3><p><em>这部分需要图片作为辅助理解，这里只是简单说下结论。</em></p>
<p><strong>MyISAM</strong></p>
<p>这个引擎中数据在物理上是按照插入顺序进行排列的。以下以「行指针」来指代行的物理位置的指针。</p>
<p>对于索引，主键索引和其他索引没有差别（只多了 UNIQUE 和 NOT NULL 的要求），索引的叶子节点包含的都是「行指针」，没有二级索引那样的两次查询，但索引的顺序和物理上存储的顺序是不同的，所以也就意味着没有聚簇索引。</p>
<p><strong>InnoDB</strong></p>
<p>InnoDB 的前面实际已经阐述了，聚簇索引（主键索引）的叶子节点存储的是「行指针」，而二级索引的叶子节点存储的是主键值。二级索引查询在内部需要先查询主键值，再查询得到「行指针」</p>
<h3 id="InnoDB-表中按主键顺序插入行"><a href="#InnoDB-表中按主键顺序插入行" class="headerlink" title="InnoDB 表中按主键顺序插入行"></a>InnoDB 表中按主键顺序插入行</h3><p>我们一般用自增的 int/long 型的列作为主键，有时也用 UUID，但从性能的角度来看，UUID 作为主键、继而成为聚簇索引并不合适，因为 UUID 是无序的，这导致每次插入的位置都是无序的。在用 UUID 作为主键的时候，在插入大量数据之后，也许需要进行 OPTIMIZE TABLE。</p>
<p>因此，使用 InnoDB 时应该尽可能地按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键来插入新行。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>覆盖索引指的是我们通过索引来直接获取列的数据，这样就不用找到数据行并提取其中数据了，节省了 I/O 操作的次数，例如：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> store_id, film_id <span class="keyword">FROM</span> sakila.inventory;</span><br></pre></td></tr></table></figure>
<p>如果 store_id 和 film_id 都建了索引，并且我们也只需要查询这两项，那么索引就覆盖了查询，这种情况下可以极大地减少数据访问量。</p>
<p>如果存在索引覆盖，我们通过 EXPLAIN 可以看到 Using index 的字眼。</p>
<h3 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h3><p>一个索引可以同时满足排序和查找行两个要求。例如 <code>ORDER BY inventory_id DESC</code>，如果其中 inventory_id 建了索引，就能用扫描索引来进行排序。</p>
<h3 id="冗余和重复的索引"><a href="#冗余和重复的索引" class="headerlink" title="冗余和重复的索引"></a>冗余和重复的索引</h3><p>在一些情况下我们会不经意地建立冗余或重复的索引：</p>
<ol>
<li><p>主键不需要被 UNIQUE 标注，也不需要被 INDEX 标注；UNIQUE 的列也不需要被 INDEX 标注。因为主键和 UNIQUE 都是通过索引来实现的，如果给主键又标 UNIQUE，又标 INDEX，就建了三个索引了。</p>
</li>
<li><p>创建索引(A, B)，再创建索引(A)就是冗余的，但是索引(B, A)和(B)都不是冗余的</p>
</li>
<li><p>索引(A, ID)中的 ID 是冗余的，因为 ID 是主键，二级索引本身就隐含了主键了。</p>
</li>
</ol>
<p>重复索引一般没什么用处，并且索引越多插入速度就越慢。</p>
<h3 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h3><p>InnoDB 使用的是行级锁，如果我们能通过索引告诉哪些行是需要遍历的，那么就可以只加锁这些行。具体使用方式就不细说了。</p>
<h2 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h2><p>维护主要有三个目的：</p>
<ol>
<li>找到并修复损坏的表：使用 CHECK TABLE 和 REPAIR TABLE 来实现</li>
<li>维护准确的索引统计信息：使用 ANALYZE TABLE</li>
<li>减少碎片：使用 OPTIMIZE TABLE</li>
</ol>
<hr>
<p>参考资料：「高性能 MySQL」</p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/mysql/" rel="tag">#MySQL</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/1469151096000/" rel="next" title="Java 并发 - JMM">
                <i class="fa fa-chevron-left"></i> Java 并发 - JMM
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/1470708587000/" rel="prev" title="MySQL 的查询缓存">
                MySQL 的查询缓存 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://live.staticflickr.com/7882/buddyicons/26146382@N07_r.jpg" alt="Yinyin Qian">
          <p class="site-author-name" itemprop="name">Yinyin Qian</p>
          <p class="site-description motion-element" itemprop="description">In me the tiger sniffs the rose</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">139</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://cn.linkedin.com/in/yyqian" target="_blank">
                  
                    <i class="fa fa-linkedin"></i>
                  
                  Linkedin
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/yyqian" target="_blank">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.flickr.com/photos/yyqian" target="_blank">
                  
                    <i class="fa fa-flickr"></i>
                  
                  Flickr
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#索引类型"><span class="nav-text">索引类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree-索引"><span class="nav-text">B-Tree 索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希索引"><span class="nav-text">哈希索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他索引"><span class="nav-text">其他索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引的优缺点"><span class="nav-text">索引的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高性能的索引策略"><span class="nav-text">高性能的索引策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前缀索引和索引选择性"><span class="nav-text">前缀索引和索引选择性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多列索引"><span class="nav-text">多列索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多列索引中的索引列的顺序"><span class="nav-text">多列索引中的索引列的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚簇索引（Clustered-Index）"><span class="nav-text">聚簇索引（Clustered Index）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二级索引（Secondary-Index）"><span class="nav-text">二级索引（Secondary Index）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB-和-MyISAM-的数据分布对比"><span class="nav-text">InnoDB 和 MyISAM 的数据分布对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB-表中按主键顺序插入行"><span class="nav-text">InnoDB 表中按主键顺序插入行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖索引"><span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用索引扫描来做排序"><span class="nav-text">使用索引扫描来做排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冗余和重复的索引"><span class="nav-text">冗余和重复的索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引和锁"><span class="nav-text">索引和锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#维护索引和表"><span class="nav-text">维护索引和表</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2008 - 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yinyin Qian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  

  

</body>
</html>
