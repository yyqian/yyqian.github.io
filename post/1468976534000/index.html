<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Java,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0">






<meta name="description" content="Java 平台类库包含丰富的并发基础构建模块，这里将列举一些最有用的模块。 同步容器类已经不建议使用的 Vector 和 Hashtable 这里就不说了。它们的替代者是 Collections.synchronizedXxxx 等工厂方法创建的容器。 我们以 synchronizedMap 方法为例，部分源码如下： 1234567891011121314151617181920212223242">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发 - 基础构建模块">
<meta property="og:url" content="http://yyqian.github.io/post/1468976534000/index.html">
<meta property="og:site_name" content="YYQIAN">
<meta property="og:description" content="Java 平台类库包含丰富的并发基础构建模块，这里将列举一些最有用的模块。 同步容器类已经不建议使用的 Vector 和 Hashtable 这里就不说了。它们的替代者是 Collections.synchronizedXxxx 等工厂方法创建的容器。 我们以 synchronizedMap 方法为例，部分源码如下： 1234567891011121314151617181920212223242">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-02-11T15:15:56.235Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 并发 - 基础构建模块">
<meta name="twitter:description" content="Java 平台类库包含丰富的并发基础构建模块，这里将列举一些最有用的模块。 同步容器类已经不建议使用的 Vector 和 Hashtable 这里就不说了。它们的替代者是 Collections.synchronizedXxxx 等工厂方法创建的容器。 我们以 synchronizedMap 方法为例，部分源码如下： 1234567891011121314151617181920212223242">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Java 并发 - 基础构建模块 | YYQIAN </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">YYQIAN</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Do not go gentle into that good night</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java 并发 - 基础构建模块
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-20T09:02:14+08:00" content="2016-07-20">
              2016-07-20
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Java 平台类库包含丰富的并发基础构建模块，这里将列举一些最有用的模块。</p>
<h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><p>已经不建议使用的 Vector 和 Hashtable 这里就不说了。它们的替代者是 Collections.synchronizedXxxx 等工厂方法创建的容器。</p>
<p>我们以 synchronizedMap 方法为例，部分源码如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> class SynchronizedMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装饰器模式，外部传入的 map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">Object</span> mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两种构造方式，使用内置互斥锁或指定的互斥锁</span></span><br><span class="line">    SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">        mutex = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SynchronizedMap(Map&lt;K,V&gt; m, <span class="keyword">Object</span> mutex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在原有方法上用 synchronized (mutex) 来包裹，实现同步访问</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.<span class="built_in">get</span>(<span class="built_in">key</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(<span class="built_in">key</span>, value);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>从以上代码可以看出，这些同步容器实际是使用的装饰器模式，在原容器的各个方法上都用 <code>synchronized (mutex)</code> 来包裹，实现同步访问。</p>
<p>这个容器在复合操作下仍然需要额外的加锁机制，例如：</p>
<ul>
<li>迭代：可能在迭代过程中元素的数量发生变化</li>
<li>跳转：通过 index 来获取元素</li>
<li>条件运算：若没有则添加，先检查后运算</li>
</ul>
<p>以下复合操作都不是线程安全的：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = <span class="built_in">list</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>.<span class="built_in">get</span>(lastIndex); <span class="comment">// 这个时候 list 的大小有可能变化了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    doSomething(<span class="built_in">vector</span>.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="keyword">String</span>&gt; strList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">String</span> str : strList) &#123;</span><br><span class="line">    doSomething(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要额外的同步来修复这些操作：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    synchronized (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = <span class="built_in">list</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>.<span class="built_in">get</span>(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized (<span class="built_in">vector</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        doSomething(<span class="built_in">vector</span>.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="keyword">String</span>&gt; strList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;());</span><br><span class="line">synchronized (strList) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> str : strList) &#123;</span><br><span class="line">        doSomething(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果遍历容器耗时很长，对容器加锁会严重影响性能，替代的方法是克隆容器，在其副本上进行迭代操作。由于副本是封闭在线程内的，即使副本本身不是线程安全的，也不需要加锁。但克隆容器也是需要额外开销的，所以需要权衡考虑。</p>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>前面的同步容器实际是把并发访问串行化来实现线程安全的。这种方法的代价是严重降低并发性、吞吐量。</p>
<p>Java 有一系列并发容器是针对多线程并发访问设计的，可以代替同步容器，极大地提高伸缩性并降低风险。以下是各个接口的并发实现：</p>
<ul>
<li>Map: ConcurrentHashMap</li>
<li>List: CopyOnWriteArrayList</li>
<li>Queue: ConcurrentLinkedQueue</li>
<li>BlockingQueue: 有若干实现</li>
<li>SortedMap, SortedSet: ConcurrentSkipListMap, ConcurrentSkipListSet</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 用一种「分段锁」代替同步容器中的全局锁，实现粒度更细的加锁机制。在需要线程安全性的时候，应当首先考虑它，而不是 Hashtable 或 synchronizedMap。</p>
<h3 id="ConcurrentMap-接口"><a href="#ConcurrentMap-接口" class="headerlink" title="ConcurrentMap 接口"></a>ConcurrentMap 接口</h3><p>当我们需要进行复合操作的时候，ConcurrentHashMap 不能像同步容器那样被施加全局锁，为此，ConcurrentMap 该接口定义了一些常用的复合操作：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V putIfAbsent(K<span class="built_in"> key</span>, V <span class="keyword">value</span>); //<span class="built_in"> key</span> 不存在是才插入</span><br><span class="line">boolean<span class="built_in"> remove</span>(Object<span class="built_in"> key</span>, Object <span class="keyword">value</span>); //<span class="built_in"> key</span> 被映射到 <span class="keyword">value</span> 是才移除</span><br><span class="line">boolean<span class="built_in"> replace</span>(K<span class="built_in"> key</span>, V oldValue, V newValue); // 当<span class="built_in"> key</span> 被映射到 oldValue 时才用 newValue 代替</span><br><span class="line">V<span class="built_in"> replace</span>(K<span class="built_in"> key</span>, V <span class="keyword">value</span>); // 仅当<span class="built_in"> key</span> 被映射到某个任意值时，才用 <span class="keyword">value</span> 代替</span><br></pre></td></tr></table></figure>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>前面说过，在使用同步容器的时候，如果需要遍历容器，就要对整个容器进行加锁来获取独占访问，或者是克隆容器，在其副本上进行遍历。CopyOnWriteArrayList 在这点上，两者都不需要就能实现线程安全。</p>
<p>它在遍历的过程中不会遇到容器被修改的情况，因为每次修改都会创建并重新发布一个新的容器副本，不会影响原来的容器。但是，每次修改都创建新的容器副本也存在一定的性能开销，因此，仅当迭代操作远远多于修改操作时，才应该使用 CopyOnWrite 容器。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列最主要是用来实现「生产者 - 消费者队列」。主要操作有可阻塞的 put 和 get 方法，以及支持定时的 offer 和 poll 方法。</p>
<p>最主要的实现是 LinkedBlockingQueue，ArrayBlockingQueue，PriorityBlockingQueue。前两者关系就和 LinkedList 与 ArrayList 类似，PriorityBlockingQueue 则是 PriorityQueue 的阻塞版本。</p>
<p>生产者 - 消费者模式可以用来解耦组件，也可以让组件并行执行，以文件索引器为例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startIndexing</span><span class="params">(<span class="built_in">File</span>[] roots)</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;<span class="built_in">File</span>&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedBlockingQueue&lt;<span class="built_in">File</span>&gt;(BOUND);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">File</span> root : roots) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> FileCrawler(<span class="built_in">queue</span>, root)).start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N_CONSUMERS; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Indexer(<span class="built_in">queue</span>)).start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把这个索引器分为爬虫和索引两个独立的功能组件（FileCrawler, Indexer），然后用一个 BlockingQueue 将两者耦合在一起，爬虫作为生产者生成 File 对象，FileCrawler 作为消费者消费 File 对象；前者是 IO 密集型，后者是 CPU 密集型，它们搭配并发执行的吞吐量要远高于串行执行的吞吐量。</p>
<p>「生产者 - 消费者队列」促进了串行线程封闭，队列中的产品是我们关注的对象，它由生产者生成，然后放入队列，再由消费者获取，三者分别属于三个线程，但是它们对单个产品的访问是串行化的，产品的所有权一直在被转移，因此不管是生产者、队列还是消费者，对该产品都有独占的访问权，产品一直被封闭在单个线程中。</p>
<p>双端队列 Deque 或 BlockingDeque 适用于「工作密取（Work Stealing）」。在「生产者 - 消费者模式」中，所有消费中从同一个队列中获取任务；而在「工作密取模式」中，每个消费者都有各自的双端队列，如果一个消费者完成自己双端队列中的任务，可以从其他消费者双端队列末尾秘密地获取工作。</p>
<p>双端队列适合既是消费者也是生产者的问题：例如爬虫访问一个链接，在分析处理这个链接页面中的内容后，会产生更多的链接。</p>
<h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><p>前面的阻塞队列是一种特殊的同步工具类，它既可以作为容器，也可以用来协助在生产者和消费者之间转移对象。接下来讨论另外三种同步工具类：闭锁（Latch）、栅栏（Barrier）以及信号量（Semaphore）。</p>
<h3 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h3><p>闭锁可以用来等待一组任务全部完成后，再执行下一个任务。它就像一扇门，只有当所有人都在门前准备好可以出发的时候，这个门才会打开，然后大伙就可以冲出去了。</p>
<p>它可以用来：</p>
<ol>
<li>等待游戏中多个玩家都已经准备好，然后游戏正式开始</li>
<li>一系列依赖的资源或库都已经加载完成，然后主程序启动（例如编译之前要先连接依赖的库）</li>
<li>一系列依赖的服务都已启动，然后本服务再启动（例如我们的 Web 应用一般都需要 MySql, Redis, RabbitMQ 等依赖的服务都启动之后，才能启动）</li>
</ol>
<p>我们以 CountDownLatch 来举例闭锁的使用，CountDownLatch 在计数器非零的状态下，await 方法会会阻塞进程，当某个任务完成，我们就调用 countDown 方法递减计数器，当计数器递减为零的时候，await 方法就停止阻塞，进程继续运行。</p>
<p>下面的 TestHarness 展示了 CountDownLatch 的用法，startGate 用来等待所有任务准备好之后同时开始；endGate 等待所有任务完成之后进行下一步操作。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> throws InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 所有线程都在这个门前等待</span></span><br><span class="line">            startGate.await();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 执行（阻塞）</span></span><br><span class="line">              task.<span class="built_in">run</span>();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">              <span class="comment">// 任务完成, 计数器减一</span></span><br><span class="line">              endGate.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            ignored.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 这个时候所有 Thread 都已经构造好了, startGate 递减为 0, 所有任务同时开始, 否则开始的时间会有先后差异</span></span><br><span class="line">    startGate.countDown();</span><br><span class="line">    <span class="comment">// 在这个门前等待所有任务完成</span></span><br><span class="line">    endGate.await();</span><br><span class="line">    <span class="comment">// 所有任务完成, 计算耗时</span></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">end</span> - start) / <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;</span><br><span class="line">    Random rnd = <span class="keyword">new</span> Random(<span class="number">137</span>);</span><br><span class="line">    <span class="comment">// 定义一个任务, 睡随机的秒数</span></span><br><span class="line">    Runnable task = () -&gt; &#123;</span><br><span class="line">      <span class="keyword">long</span> sec = rnd.nextInt(<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(sec * <span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"I slept %d seconds."</span>, sec));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 输出总耗时</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"The total time costs is: %d seconds."</span>, timeTasks(<span class="number">4</span>, task)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><p>栅栏和闭锁有相似之处，它的作用是等待所有线程都到了某一个点之后，再同时进行下一步的计算。例如：如果我们要模拟一个盒子中的分子运动，我们可以让每个分子运动轨迹的计算并行执行，但在每个时间间隔点，我们都要等待所有的分子当前位置计算完毕，才能进行下一个时间点的计算，因为单个分子下一时刻的位置依赖于上一时刻其他分子的位置，所以在每个时间点，我们都需要一个栅栏。</p>
<p>栅栏可以用以下方式构造，我们告知需要等待的线程的数目，以及所有线程到达之后下一步的操作：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(count,</span><br><span class="line">    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">            <span class="comment">//xxxxx</span></span><br><span class="line">        &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>在需要用栅栏进行同步的线程中，我们可以下面的方式调用栅栏，在当前阶段的任务处理完毕之后，调用 await 方法，表示已完成，等待其他线程也完成之后进行下一阶段的操作：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理现阶段所有的任务</span></span><br><span class="line">barrier.<span class="keyword">await</span>();</span><br></pre></td></tr></table></figure>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>FutureTask 可以定义一个任务，该任务会有一个返回结果，我们可以用它的 get 方法来获取返回结果，如果我们调用 get 的时候任务还没完成，将阻塞线程；如果完成就返回结果。（这个和 Clojure 中的 future 在模式上是相同的）</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PreLoader</span> &#123;</span></span><br><span class="line">  private final FutureTask&lt;Long&gt; future = <span class="keyword">new</span> FutureTask&lt;Long&gt;<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    long sleep = <span class="number">3287</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    Thread.sleep(sleep);</span></span></span><br><span class="line"><span class="function"><span class="params">    System.out.println(String.format(<span class="string">"I slept %d milliseconds."</span>, sleep));</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> sleep;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;)</span>;</span></span><br><span class="line"><span class="function">  <span class="title">private</span> <span class="title">final</span> <span class="title">Thread</span> <span class="title">thread</span> = <span class="title">new</span> <span class="title">Thread</span><span class="params">(future)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">void</span> <span class="title">start</span><span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">thread</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">Long</span> <span class="title">get</span><span class="params">()</span> <span class="title">throws</span> <span class="title">ExecutionException</span>, <span class="title">InterruptedException</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">future</span>.<span class="title">get</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="title">throws</span> <span class="title">ExecutionException</span>, <span class="title">InterruptedException</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">PreLoader</span> <span class="title">loader</span> = <span class="title">new</span> <span class="title">PreLoader</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"Started loading"</span>)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">loader</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"Started getting"</span>)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"Result: "</span> + loader.get())</span>;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>一般也称为计数信号量（Counting Semaphore），它可以用来实现资源池，或者给容器加边界。</p>
<p>我们可以想象成某个资源有固定数量的许可证，我们可以通过 acquire 方法获取许可证，然后访问资源，访问完毕后调用 release 方法归还许可证。但是如果我们 acquire 的时候许可证已经都发光了，线程就会阻塞，等待其他线程归还许可证之后，我们再获取许可证进行访问。因此，我们可以控制同时访问一资源的线程数量，实现一个有固定大小的资源池。</p>
<p>我们在同步的时候用的互斥锁（mutex）就是信号量的一个特例，它是一个二值信号量，只保有一个许可证，一旦有线程 acquire 之后，其他线程就都得阻塞等待它 release。</p>
<p>以下是一个有边界的 HashSet，通过信号量来实现：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;T&gt; &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; <span class="built_in">set</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">set</span> = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">    <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T object)</span> throws InterruptedException </span>&#123;</span><br><span class="line">    semaphore.acquire();</span><br><span class="line">    <span class="keyword">boolean</span> wasAdded = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      wasAdded = <span class="built_in">set</span>.add(object);</span><br><span class="line">      <span class="keyword">return</span> wasAdded;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      <span class="keyword">if</span> (!wasAdded) semaphore.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> wasRemoved = <span class="built_in">set</span>.<span class="built_in">remove</span>(object);</span><br><span class="line">    <span class="keyword">if</span> (wasRemoved) semaphore.<span class="built_in">release</span>();</span><br><span class="line">    <span class="keyword">return</span> wasRemoved;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;</span><br><span class="line">    BoundedHashSet&lt;Integer&gt; boundedHashSet = <span class="keyword">new</span> BoundedHashSet&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> parm = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          boundedHashSet.add(parm);</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"add "</span> + parm);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"等待任务完成"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"remove 3"</span>);</span><br><span class="line">    boundedHashSet.<span class="built_in">remove</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的输出为：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">等待任务完成</span><br><span class="line"><span class="builtin-name">add</span> 0</span><br><span class="line"><span class="builtin-name">add</span> 2</span><br><span class="line"><span class="builtin-name">add</span> 4</span><br><span class="line"><span class="builtin-name">add</span> 3</span><br><span class="line"><span class="builtin-name">add</span> 1</span><br><span class="line"><span class="builtin-name">remove</span> 3</span><br><span class="line"><span class="builtin-name">add</span> 5</span><br></pre></td></tr></table></figure>
<p>在这个类中，add 方法获取许可证，remove 方法归还许可证。</p>
<p>我们在 main 方法中构造了一个大小限定为 5 的 Set，然后我们启动 6 个线程，每个线程添加一个元素，那么前 5 个线程会添加成功并结束任务，第六个线程会被阻塞，直到我们从中移除一个元素，它才会成功地添加到容器中并返回。</p>
<h2 id="应用：构造缓存"><a href="#应用：构造缓存" class="headerlink" title="应用：构造缓存"></a>应用：构造缓存</h2><p>以下是一个缓存的示例。这里有几个注意点：</p>
<ol>
<li>使用 ConcurrentHashMap 可以避免同时读写某个 key 造成的并发问题</li>
<li>Future<v> 可以避免当两个线程同时发现某个 key 没有被缓存，然后同时开始计算该 key。用了 Future 之后，慢了一步的线程会在 Future.get() 方法上阻塞，等待另一个线程计算完毕返回结果。</v></li>
<li>putIfAbsent 避免「若没有则添加」这个复合操作带来的并发问题</li>
<li>cache.remove(key) 这一句是避免 Future 计算失败，导致缓存的是错误信息而不是真正的结果。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer</span>&lt;K, V&gt; &#123;</span></span><br><span class="line">  <span class="comment">// 两点优化: 使用 Future&lt;V&gt; 和 ConcurrentHashMap</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;K, Future&lt;V&gt;&gt; cache</span><br><span class="line">      = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> K key)</span> throws InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      Future&lt;V&gt; <span class="built_in">future</span> = cache.<span class="built_in">get</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">future</span> == null) &#123;</span><br><span class="line">        FutureTask&lt;V&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">          <span class="comment">// 实际的计算任务, 为了简化代码, 执行一个虚拟的任务</span></span><br><span class="line">          Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">          <span class="keyword">return</span> (V)key;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">future</span> = cache.putIfAbsent(key, futureTask);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">future</span> == null) &#123;</span><br><span class="line">          <span class="built_in">future</span> = futureTask;</span><br><span class="line">          futureTask.<span class="built_in">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">future</span>.<span class="built_in">get</span>();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">        cache.<span class="built_in">remove</span>(key);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;</span><br><span class="line">    Memoizer&lt;Integer, Integer&gt; memoizer = <span class="keyword">new</span> Memoizer&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> arg = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"First run: "</span> + memoizer.compute(arg));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Second run: "</span> + memoizer.compute(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要概括介绍在并发情况下，我们可使用的基础构建模块，目的是为了构造线程安全的类：</p>
<ol>
<li>同步容器：最基础的线程安全的类，实现的方式是使用 synchronized 关键词来将并发访问串行化，缺陷就是串行化后吞吐量大大降低。</li>
<li>并发容器：实现的方式根据容器类型各异，但至少不需要同步串行化，可以在满足线程安全的前提下大幅提高性能；对于复合操作，可以使用额外定义的 API 来操作，而不要自行通过客户端加锁来实现。</li>
<li>阻塞队列：可以用来实现生产者 - 消费者模式，这个模式有利于促成解耦和线程封闭。</li>
<li>同步工具类：闭锁、栅栏、FutureTask、信号量，它们的作用各异，但总体来说都是为了协同各个线程之间的交互。</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">Java 并发编程实战</a></li>
</ul>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag">#Java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/1468391936000/" rel="next" title="Java 源码分析 - ArrayDeque">
                <i class="fa fa-chevron-left"></i> Java 源码分析 - ArrayDeque
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/1469087760000/" rel="prev" title="Java 并发 - Executor">
                Java 并发 - Executor <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/default_avatar.jpg" alt="Yinyin Qian">
          <p class="site-author-name" itemprop="name">Yinyin Qian</p>
          <p class="site-description motion-element" itemprop="description">In me the tiger sniffs the rose</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">139</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://cn.linkedin.com/in/yyqian" target="_blank">
                  
                    <i class="fa fa-linkedin"></i>
                  
                  Linkedin
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/yyqian" target="_blank">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.flickr.com/photos/yyqian" target="_blank">
                  
                    <i class="fa fa-flickr"></i>
                  
                  Flickr
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#同步容器类"><span class="nav-text">同步容器类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发容器"><span class="nav-text">并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentMap-接口"><span class="nav-text">ConcurrentMap 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞队列"><span class="nav-text">阻塞队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步工具类"><span class="nav-text">同步工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#闭锁"><span class="nav-text">闭锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栅栏"><span class="nav-text">栅栏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask"><span class="nav-text">FutureTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量"><span class="nav-text">信号量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用：构造缓存"><span class="nav-text">应用：构造缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2008 - 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yinyin Qian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  

  

</body>
</html>
