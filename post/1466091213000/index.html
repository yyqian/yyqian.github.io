<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="钱寅垠, Yinyin Qian, yyqian">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0">






<meta name="description" content="最近在用零碎的时间做做 LeetCode，锻炼下算法功底，这里把做过的题目的解题思路汇总一下。 当前免费的题目有 286 题（2016/07/07），各难度总数统计：  Easy: 78 Medium: 142 Hard: 66  当前已完成的统计（2016/07/07）：  Easy: 48 Medium: 49 Hard: 3  未完成统计：  Easy: 30 Medium: 93 Hard">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 解题思路汇总">
<meta property="og:url" content="http://yyqian.github.io/post/1466091213000/index.html">
<meta property="og:site_name" content="YYQIAN">
<meta property="og:description" content="最近在用零碎的时间做做 LeetCode，锻炼下算法功底，这里把做过的题目的解题思路汇总一下。 当前免费的题目有 286 题（2016/07/07），各难度总数统计：  Easy: 78 Medium: 142 Hard: 66  当前已完成的统计（2016/07/07）：  Easy: 48 Medium: 49 Hard: 3  未完成统计：  Easy: 30 Medium: 93 Hard">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/c/c1/Binary-reflected_Gray_code_construction.svg">
<meta property="og:updated_time" content="2022-02-11T15:15:56.235Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode 解题思路汇总">
<meta name="twitter:description" content="最近在用零碎的时间做做 LeetCode，锻炼下算法功底，这里把做过的题目的解题思路汇总一下。 当前免费的题目有 286 题（2016/07/07），各难度总数统计：  Easy: 78 Medium: 142 Hard: 66  当前已完成的统计（2016/07/07）：  Easy: 48 Medium: 49 Hard: 3  未完成统计：  Easy: 30 Medium: 93 Hard">
<meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/c/c1/Binary-reflected_Gray_code_construction.svg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> LeetCode 解题思路汇总 | YYQIAN </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">YYQIAN</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Do not go gentle into that good night</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                LeetCode 解题思路汇总
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-16T23:33:33+08:00" content="2016-06-16">
              2016-06-16
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>最近在用零碎的时间做做 LeetCode，锻炼下算法功底，这里把做过的题目的解题思路汇总一下。</p>
<p>当前免费的题目有 286 题（2016/07/07），各难度总数统计：</p>
<ul>
<li>Easy: 78</li>
<li>Medium: 142</li>
<li>Hard: 66</li>
</ul>
<p>当前已完成的统计（2016/07/07）：</p>
<ul>
<li>Easy: 48</li>
<li>Medium: 49</li>
<li>Hard: 3</li>
</ul>
<p>未完成统计：</p>
<ul>
<li>Easy: 30</li>
<li>Medium: 93</li>
<li>Hard: 63</li>
</ul>
<p>按照每天 1 Easy, 3 Medium, 1 Hard 的题量，30 天可以清空所有免费的 Easy 和 Medium。</p>
<h2 id="总结一些技巧和注意点"><a href="#总结一些技巧和注意点" class="headerlink" title="总结一些技巧和注意点"></a>总结一些技巧和注意点</h2><h3 id="注意处理特殊情况"><a href="#注意处理特殊情况" class="headerlink" title="注意处理特殊情况"></a>注意处理特殊情况</h3><p>除数为零，输入为 null，数组/列表长度为零，int 溢出</p>
<h3 id="列表问题的技巧"><a href="#列表问题的技巧" class="headerlink" title="列表问题的技巧"></a>列表问题的技巧</h3><ul>
<li>runner 和 walker 用来探测闭环</li>
<li>用 sentinel 来记录头部，适当的时候也记录下尾部。</li>
</ul>
<h3 id="数组问题"><a href="#数组问题" class="headerlink" title="数组问题"></a>数组问题</h3><ul>
<li>用若干个指针来记录和移动</li>
<li>先排序试试(一般 nlgn 复杂度)</li>
<li><a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank" rel="noopener">Maximum subarray problem</a></li>
</ul>
<h3 id="数字问题技巧"><a href="#数字问题技巧" class="headerlink" title="数字问题技巧"></a>数字问题技巧</h3><ul>
<li>x &amp; (x - 1) 来判断是否为 2 的 n 次方</li>
<li>利用 Prime Number 的性质<a id="more"></a>
<h3 id="常见算法应用"><a href="#常见算法应用" class="headerlink" title="常见算法应用"></a>常见算法应用</h3></li>
</ul>
<ol>
<li>DP</li>
<li>dfs 和 bfs</li>
<li>二分搜索</li>
<li>分治</li>
<li>hashtable</li>
<li>用迭代 + stack/queue/array 来取代递归</li>
</ol>
<p>经典题目汇集：</p>
<p>(137 &amp; 260), 148, 210, 208, 215, 221, 236, 238, 257, 264</p>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul>
<li>dfs: 把路径集合传到递归函数中，在递归之前 push 元素，递归之后 pop 元素，这个路径就可以反复利用</li>
<li>bfs: 对于深度，可以用 queue，进入下一层的时候，先获取当前 queue 的大小 n，然后循环 n 次，把这一层的元素都处理完，这时候层级++，进入下层迭代。见 127 题。</li>
</ul>
<h2 id="各个题目的解题思路"><a href="#各个题目的解题思路" class="headerlink" title="各个题目的解题思路"></a>各个题目的解题思路</h2><p><strong>202. Happy Number</strong></p>
<p>这个题目难点在于寻找闭环，有三个解法：</p>
<ol>
<li>用链表的 runner 和 walker 方法来寻找闭环</li>
<li>用一个 set 来记录出现过的数字，如果有重复的就说明有闭环</li>
<li>如果有闭环，则闭环中必定有 4（证明方法未知），根据这点来判定</li>
</ol>
<p><strong>350. Intersection of Two Arrays II</strong></p>
<p>解法一：</p>
<ol>
<li>先把两个数组各自排序</li>
<li>用两个指针指向两个数组当前比较的位置，根据比较结果来移动指针和添加交叉值</li>
</ol>
<p>解法二：</p>
<ol>
<li>用 hashtable 来记录数组 1 中每个数字出现的次数</li>
<li>遍历数组 2，如果 hashtable 中存在当前元素就添加该元素，同时将哈希表中该元素的出现次数减一</li>
</ol>
<p><strong>349. Intersection of Two Arrays</strong></p>
<p>解法一：用两个 set，数组 1 转换成 set，结果用 set 作为数据结构。然后遍历数组 2 进行比较，如果符合则加入结果的 set</p>
<p>解法二：跟 350 题的解法一类似，不同点是结果用 set 来作为数据结构</p>
<p><strong>231. Power of Two</strong></p>
<p>解法一：用 n &amp; (n-1) trick</p>
<p>解法二：数一下 bit 为 1 的数目，符合的只会有 1 个</p>
<p><strong>326. Power of Three</strong></p>
<p>解法一：递归地检查余数，然后除以 3</p>
<p>解法二：3^19 = 1162261467 是 int 所能容纳的最大的符合条件的数，用它来进行取模操作。</p>
<p><strong>342. Power of Four</strong></p>
<p>326 的解法二在这行不通，因为 4 不是素数。</p>
<p>Power of Four 的特点是 bit = 1 的位置出现在奇数位，我们用以下步骤：</p>
<ol>
<li>先用 n &amp; (n-1) trick 检查是否是 Power of Two</li>
<li>然后检查 1 出现的奇偶位：检查 0b010101…010101 (也就是 0x55555555) &amp; num 的结果是否为 0</li>
</ol>
<p><strong>6. ZigZag Conversion</strong></p>
<p>用 numRows 长度的 StringBuilder 缓存每一行的字符，然后一个指针指 rows，一个指针指下一个字符。</p>
<p><strong>204. Count Primes</strong></p>
<p>参照 Sieve of Eratosthenes 算法</p>
<p><strong>7. Reverse Integer</strong></p>
<p>迭代地用 mod 10 取最低位，然后最低位 * 10 添加到结果中。麻烦的地方在于检查 overflow。</p>
<p><strong>9. Palindrome Number</strong></p>
<p>7 的解法可以用在这里，也同样要注意 overflow。</p>
<p><strong>146. LRU Cache</strong></p>
<p>实现 LRU 的方法：用双向链表（LinkedList）来存放每个数据节点，当访问某个节点的时候，把该节点从链表中删除，然后再添加到链表的头部。当链表满了，就把尾部的节点删除。</p>
<p>get 方法要做的事：访问 Map 获得 该 key 对应的节点，把该节点移到头部，返回该节点的值</p>
<p>put 方法要做的事：如果存在该 key， 则把访问的节点移到头部，并且更新该节点的值，然后返回；如果空间不足， 则删除尾巴处的节点，也同时从 Map 中删除，直到空间足够；如果空间足够，则创建新的节点，把该节点加到链表头部，并且在 Map 中也添加该 key。</p>
<p><strong>206. Reverse Linked List</strong></p>
<p>Linked List 正常添加节点都是添加到头部，我们遍历一遍 List，每次都往头部添加，自然就得到一个反序的 List 了</p>
<p><strong>92. Reverse Linked List II</strong></p>
<p>在 206 的基础上，我们需要略过头部不需要反序的部分，并且在交换的时候注意要维持尾部的链条。</p>
<p><strong>169. Majority Element</strong></p>
<p>有点 tricky，用一个计数器去计算当前猜测字符出现的次数，如果计数器归零，则换个数字。(Boyer-Moore Majority Vote algorithm)</p>
<p><strong>229. Majority Element II</strong></p>
<p>这个和 169 类似，用 Boyer-Moore Majority Vote algorithm</p>
<p><strong>8. String to Integer (atoi)</strong></p>
<p>核心的部分，就是用 charAt 取字符，减去字符 0，得到的就是数字了。这里要注意头尾空格，正负号，以及 int 溢出。</p>
<p><strong>77. Combinations</strong></p>
<p>自己的做法：用分治法，C(n,k) = C(n-1,k-1) + C(n-1,k)</p>
<p>combine(n, k) 的结果可以由两部分组成：</p>
<ol>
<li>组合里有元素 n: combine(n - 1, k - 1) 的每个组合都加上元素 n</li>
<li>组合里没有元素 n: combine(n - 1, k)</li>
</ol>
<p>考虑边界情况，把以上两个组合合并</p>
<p><strong>54. Spiral Matrix</strong></p>
<p><strong>59. Spiral Matrix II</strong></p>
<p>有两种方法：</p>
<ol>
<li>一圈一圈走，从最外圈往内圈走，每圈可以看成一次迭代</li>
<li>用上下左右四个指针维持接下来要走的路径，每走完一条边，相应的指针就移动一格。</li>
</ol>
<p><strong>341. Flatten Nested List Iterator</strong></p>
<p>用 Stack 来存储，如果栈顶是数组，就把它解开来 push 到 Stack 中，迭代直到栈顶是单个数字。</p>
<p><strong>55. Jump Game</strong></p>
<p>可以用深度优先搜索来解决：把每个索引当做一个顶点，顶点的值决定了可以连接的后面的顶点。但这个算法不是最优的，会超时。</p>
<p>高效的做法是：从结尾出发，我们用一个 last 变量来保存最近一次能到达的点，如果当前点能到达 last 点，我们就把这个点设定为 last。前面的点如果连 last 点也到达不了，last 之后的点就更到达不了，所以只要与 last 进行比较就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= last) last = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>45. Jump Game II</strong></p>
<p>同 55，可以考虑用广度优先搜索来做，用 edgeTo 数组来保存路径，最后数一下所走的路径，可以 AC，但效率比较低。</p>
<p>更聪明的做法是，遍历数组，计算每个点能到达的最远距离，用一个 max 变量维持当前 level 所能到达的最远距离，如果当前 level 已经到达边界的时候，用 max 来设定下一个 level 的边界。</p>
<p><strong>166. Fraction to Recurring Decimal</strong></p>
<p>回想一下你是如何手动算除法的。</p>
<p><strong>14. Longest Common Prefix</strong></p>
<p>不排序的做法：先计算 0，1 两个位置的字符串的 lcp，然后遍历后面的字符串，跟 lcp 比较得到新的 lcp</p>
<p>排序的做法：先排序，然后直接计算第一个和最后一个的 lcp</p>
<p><strong>347. Top K Frequent Elements</strong></p>
<p>用一个 Map 来统计每个数字的频率，然后用桶排序，每个桶对应一个频率，桶的大小是数组大小加一（因为频率可以是 0 ~ N），一组桶用 List<integer>[] 来表示，每个桶的链表上挂对应频率的数字。然后从每个桶挨个取就可以了。</integer></p>
<p><strong>111. Minimum Depth of Binary Tree</strong></p>
<p>用递归法，注意要处理左右节点是否为 null 组合成的四种情况。</p>
<p><strong>19. Remove Nth Node From End of List</strong></p>
<p>用一个落后 n + 1 的指针跟随当前指针移动，当当前指针指向最后一个元素的时候，落后的指针的下一个就是要移除的元素。</p>
<p><strong>2. Add Two Numbers</strong></p>
<p>构造两个 Node，sentinel 用来记录头部，pre 用来记录上一个 Node，这样就能向尾部添加新的元素，需要注意的就是进位问题</p>
<p><strong>3. Longest Substring Without Repeating Characters</strong></p>
<p>利用哈希表存储字符和索引的关系，并维护指向符合条件字符串头尾的两个指针。</p>
<p><strong>5. Longest Palindromic Substring</strong></p>
<p>遍历所有字符，将单个或相邻两个字符进行展开，获得最大的长度。</p>
<p><strong>11. Container With Most Water</strong></p>
<p>用两个指针，一个指头部，一个指尾部，计算完面积之后，如果头部的高度小于尾部的高度，则头部的指针右移（因为此时尾部指针左移不可能得到比当前更小的面积）；反之尾部的指针左移。</p>
<p><strong>70. Climbing Stairs</strong></p>
<p>动态规划，DP</p>
<p><strong>121. Best Time to Buy and Sell Stock</strong></p>
<p><strong>53. Maximum Subarray</strong></p>
<p>以上两题参照：<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank" rel="noopener">Maximum subarray problem</a></p>
<p><strong>122. Best Time to Buy and Sell Stock II</strong></p>
<p>改动之后这题很简单，如果我们把股价变动的图画出来，只要将所有的正数求和就可以了。</p>
<p><strong>62. Unique Paths</strong></p>
<p>有两个方法：</p>
<ol>
<li>用 DP，P(m, n) = P(m-1, n) + P(m, n-1)</li>
<li>总共需要 m-1 次向下，n-1 次向右，总的步数是 m+n-2，结果就是 C^(n-1)_(m+n-2)</li>
</ol>
<p><strong>63. Unique Paths II</strong></p>
<p>62 题排列组合的方法貌似不适用了，所以只能用 DP，节省空间的做法是利用参数的矩阵来存 DP 的中间结果，这样就不需要额外的空间复杂度了。</p>
<p><strong>64. Minimum Path Sum</strong></p>
<p>虽然这题貌似可以用 dijkstra 来解决，但实际 overkill 了，只要从左到右、从上到下遍历一遍，每个经过的顶点都不可能再被访问一遍，然后用贪心算法，局部作出最优选择就可以了。</p>
<p><strong>96. Unique Binary Search Trees</strong></p>
<p>假设计算 BST 个数的函数是 G(n), 以某个数字 i 为根的树的个数为 F(i, n)。我们可以得到 <code>G(n) = F(1, n) + F(2, n) + ... + F(n, n)</code>。数字 i 的两个分支分别是 1,…,i-1 和 i+1,…,n 组成的两棵树，因此 F(i, n) = G(i-1) * G(n-i)。最后，我们得到：</p>
<p><code>G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)</code></p>
<p><strong>95. Unique Binary Search Trees II</strong></p>
<p>跟 96 题思路类似，不过这里不能用迭代法，只能用递归：选一个数字作为根，分成两个数字连续的分支，同样是 DP 的思维。</p>
<p><strong>15. 3Sum</strong></p>
<p><strong>16. 3Sum Closest</strong></p>
<p>以上两个问题类似，没什么很巧妙的办法，先排序，从左到右一个个检查，选定一个之后，剩余的序列中，用两个指针一个指头部，一直指尾巴，N^2 的复杂度。</p>
<p><strong>18. 4Sum</strong></p>
<p>类似 3Sum，但是这里要多一重循环，头部需要两个指针，尾部也需要两个指针，复杂度是 N^3。</p>
<p><strong>22. Generate Parentheses</strong></p>
<p>这题看似可以用 DP，实际上用 DP 解太复杂了。我们只要一笔一笔往下写，每一笔都会有可能出现两个分支：写左括号或者右括号，但这两个分支不一定有效，写右括号的时候当前的左括号数目必须大于当前右括号数目。</p>
<p><strong>20. Valid Parentheses</strong></p>
<p>用一个 stack，遇到左括号就入栈，遇到右括号就从出栈并检查是否匹配。</p>
<p><strong>21. Merge Two Sorted Lists</strong></p>
<p>可以用递归做，也可以用迭代做。</p>
<p><strong>24. Swap Nodes in Pairs</strong></p>
<p>用递归做最简单，处理头部两个节点，剩下的就递归。</p>
<p><strong>17. Letter Combinations of a Phone Number</strong></p>
<p>可以用分治法，合并分割后的两个结果。</p>
<p><strong>26. Remove Duplicates from Sorted Array</strong></p>
<p><strong>27. Remove Element</strong></p>
<p>以上两个类似。比较简单，计数器既可以作为结果，又可以用来作为记录当前能填充位置的指针。</p>
<p><strong>28. Implement strStr()</strong></p>
<p>就是 substring 的算法，可以用 KMP，如果 KMP 复杂的话就用暴力解法。</p>
<p><strong>29. Divide Two Integers</strong></p>
<p>除法的部分可以用位左移操作，用类似二分搜索的办法来寻找结果。还有个 tip 就是把 int 转换为 long 进行内部操作，在得到结果之后，再根据结果判断是否要给出溢出异常。</p>
<p><strong>31. Next Permutation</strong></p>
<p>我的做法是先找到需要替换的最左的位置，然后替换合适的数字，替换完之后有个一截需要反转下顺序。这里要注意观察序列的排序情况。</p>
<p><strong>34. Search for a Range</strong></p>
<p>lgN 复杂度的一般只有用二分搜索，这里的二分搜索在匹配之后，要记录当前位置，然后继续向两边进行二分搜索，试图找到该 Target 的边界。</p>
<p><strong>35. Search Insert Position</strong></p>
<p>还是用二分搜索，关键点是在不匹配的情况下，从最后一次比较中得到应当插入的位置。</p>
<p><strong>36. Valid Sudoku</strong></p>
<p>可以定出左上角和右上角两个顶点，然后三种情况可以用同一个函数进行判断。</p>
<p><strong>38. Count and Say</strong></p>
<p>比较简单。每次都判断下一个字符是于当前相同，然后有计数器计数相等的个数。</p>
<p><strong>39. Combination Sum</strong></p>
<p><strong>40. Combination Sum II</strong></p>
<p>40 题可以用 DFS，但特别要注意的是重复元素的问题，谨慎处理相同元素节点之间的跳转。</p>
<p><strong>43. Multiply Strings</strong></p>
<p>用我们手算的方法去做，构造一个数组，记录每一位的数字，注意处理进位。</p>
<p><strong>46. Permutations</strong></p>
<p>分治法。</p>
<p><strong>47. Permutations II</strong></p>
<p>用 dfs，配合 path 列表和 used 数组，这里有个诀窍是传入利用类似堆栈的形式重复利用 path 列表。</p>
<p><strong>48. Rotate Image</strong></p>
<p>有两种 in-place 方法：</p>
<ol>
<li>每个点旋转四次后都会回到原来的位置，所以可以以四个点为一组进行 swap</li>
<li>旋转是翻转和转置的组合，翻转和转置都可以很容易地 in-place 进行</li>
</ol>
<p><strong>49. Group Anagrams</strong></p>
<p>第一步：如果把字符串转换成字符数组，然后字符转 int 之后求和，如果是 Anagrams，求和肯定相同，但反过来不一定，这个相当于是在计算 hashCode，但可能会发生 hash collision<br>第二步：设计一个不会发生 collision 的 hash function，思路就是用 prime number，把 24 个英文字母映射到不同的 prime number，然后连乘得到 hashCode</p>
<p><strong>50. Pow(x, n)</strong></p>
<p>递归，n 每次降一半</p>
<p><strong>58. Length of Last Word</strong></p>
<p>很奇怪的题目，特别简单</p>
<p><strong>61. Rotate List</strong></p>
<p>可以把它变成一个环，然后在合适的地方把环断开。</p>
<p><strong>60. Permutation Sequence</strong></p>
<p>对于第一个字符我们是可以计算出来的，计算出来之后我们把它添加到结果，然后处理下一个字符，下一个字符的位置可以是看做一个 subarray，这时候字符集少了一个字，我们可以在最初用一个有序的 list 来保存当前尚未用过的数字，用完后把它移除。</p>
<p><strong>66. Plus One</strong></p>
<p>比较简单，一个小 trick 是如果最高为进位，只有可能是整个序列是 999999, 这个时候只要新建一个数组，然后最高为设置为 1 就可以了，余下的都是 0。</p>
<p><strong>67. Add Binary</strong></p>
<p>我们可以用 XOR 和加法来判断当前位和进位的数字。</p>
<p><strong>69. Sqrt(x)</strong></p>
<p>用二分搜索，注意 overflow</p>
<p><strong>71. Simplify Path</strong></p>
<p>用 stack，类似状态机，遇到 / 就 push，pop 或什么都不做。</p>
<p><strong>73. Set Matrix Zeroes</strong></p>
<p>我们先遍历一遍看看哪些位置是零，这里的 trick 是我们可以不用 Set 来存这些零点的位置，只要把这个点所在行或者列的头部标为 0 即可，用这个点来存放信息。</p>
<p><strong>74. Search a 2D Matrix</strong></p>
<p>二分搜索，把二维数组还原成一维就行。</p>
<p><strong>75. Sort Colors</strong></p>
<p>在头尾各用一个指针，在遍历数组的时候，遇到 0 就向头部 swap，遇到 2 就向尾部 swap。</p>
<p><strong>78. Subsets</strong></p>
<p>用迭代，一个个元素加上去</p>
<p><strong>90. Subsets II</strong></p>
<p>当有重复元素的时候，我们先数一下有几个重复的，然后在原有的结果上，添加 1 个重复的元素、添加 2 个。。。直到添加所有的重复元素。然后再处理下一个元素。</p>
<p><strong>89. Gray Code</strong></p>
<p>解法一：迭代，在(n - 1)的基础上加一个 0 或者 1。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Binary-reflected_Gray_code_construction.svg" alt></p>
<p>解法二：直接用公式：G(i) = i^ (i/2)，暂时还没研究为什么这个公式可行。<a href="https://en.wikipedia.org/wiki/Gray_code" target="_blank" rel="noopener">wiki</a></p>
<p><strong>91. Decode Ways</strong></p>
<p>DP，把字符挨个往上加，迭代更新结果。</p>
<p><strong>86. Partition List</strong></p>
<p>维护两个 List，一个存放小于 x 的元素，另一个存放大于等于 x 的元素，遍历完之后把它们接起来。维护这两个 List 的时候用四个指针指向它们的头尾。</p>
<p><strong>101. Symmetric Tree</strong></p>
<p>递归</p>
<p><strong>94. Binary Tree Inorder Traversal</strong></p>
<p><strong>144. Binary Tree Preorder Traversal</strong></p>
<p><strong>145. Binary Tree Postorder Traversal</strong></p>
<p>递归法，这个方法最容易揭示这几个遍历方法的本质</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inorder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addInorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addInorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        addInorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        addInorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preorder，只要在前面的基础上改下递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preAdd</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preAdd(root.left, res);</span><br><span class="line">        preAdd(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Postorder，同上</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postAdd</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        postAdd(root.left, res);</span><br><span class="line">        postAdd(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>迭代法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inorder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// preorder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postorder: postorder 的顺序是 left-right-root，而 preorder 的顺序是 root-left-right。我们先求 postorder 的倒序：root-right-left，这个只要在 preoder 算法基础上稍微改下就行，然后把结果倒序。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>79. Word Search</strong></p>
<p>用递归一个个字去检查，可以用 marked 数组来保存访问过的字，也可以用 ^ 256 来把访问过的字转换为不符合规范的，递归回来之后再 ^ 256 就恢复了。</p>
<p><strong>80. Remove Duplicates from Sorted Array II</strong></p>
<p>对于这种数组，不需要 swap，只要赋值过去就可以了。另外，用变量 i 维持下个添加的位置，判断是否要往头部添加的判断条件是当前值 n 是否等于 nums[i-2]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">2</span> || n != nums[i - <span class="number">2</span>]) nums[i++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>116. Populating Next Right Pointers in Each Node</strong></p>
<p>定义一个辅助的递归方法，参数是两个相邻元素，把两者连起来，然后递归地调用它们的子节点。</p>
<p><strong>33. Search in Rotated Sorted Array</strong></p>
<p>两种解法：</p>
<ol>
<li><p>比较笨的：我们可以做两次二分搜索，一次用来查找起点，第二次用来查找元素。</p>
</li>
<li><p>我们还是正常做二分搜索，每次分成两部分之后，必定会有一部分是升序的，这一点是关键。有了这一点，我们可以在这一部分中轻松地判断 target 是否在其中，如果不在，则在另一部分。其他的跟正常的二分相同，就是判断条件稍微多点。</p>
</li>
</ol>
<p><strong>81. Search in Rotated Sorted Array II</strong></p>
<p>同 33 题，分成两部分，判断哪一部分是升序的，但不同点是：分成两部分之后，有可能两部分都不是升序的（因为有重复元素），这个时候一种选择是把两部分都做二分搜索，用递归法比较容易达到这点。</p>
<p><strong>82. Remove Duplicates from Sorted List II</strong></p>
<p>这题用递归思路最清晰。</p>
<p><strong>93. Restore IP Addresses</strong></p>
<p>类似 DFS 的做法，递归地遍历所有可行的下一个节点</p>
<p><strong>98. Validate Binary Search Tree</strong></p>
<p>我的做法是用 inorder 遍历，二叉搜索是的中序遍历得到的数组应当是有序的（从小到大）。</p>
<p>最好的做法是用递归，递归函数传入值的下界和下界。这样遍历一遍就能完成。</p>
<p><strong>102. Binary Tree Level Order Traversal</strong></p>
<p><strong>107. Binary Tree Level Order Traversal II</strong></p>
<p>BST，用一个 Queue，不过这儿需要每一层都中断一下。</p>
<p><strong>103. Binary Tree Zigzag Level Order Traversal</strong></p>
<p>我的解法同 102，只是把 Queue 改用 Stack，还有先加左元素还是右元素需要根据层级判断一下</p>
<p><strong>105. Construct Binary Tree from Preorder and Inorder Traversal</strong></p>
<p><strong>106. Construct Binary Tree from Inorder and Postorder Traversal</strong></p>
<p>很经典，有助于更深入理解这几种遍历。比较明了的方法是，用一个 HashMap 保存 inorder 数组的映射，然后利用结构，递归地构造左分支和右分支</p>
<p><strong>108. Convert Sorted Array to Binary Search Tree</strong></p>
<p>二分和递归</p>
<p><strong>109. Convert Sorted List to Binary Search Tree</strong></p>
<p>可以用个 HashMap，仍然用二分和递归做，但这样得遍历两次</p>
<p>更好的做法是反向的中序遍历，需要增加一个 ListNode 属性。</p>
<p><strong>110. Balanced Binary Tree</strong></p>
<p>递归检查两棵子树的高度是否差值大于 1</p>
<p><strong>112. Path Sum</strong></p>
<p>递归</p>
<p><strong>113. Path Sum II</strong></p>
<p>dfs，反复利用 Stack 形式的 path 变量（用来存储路径）</p>
<p><strong>114. Flatten Binary Tree to Linked List</strong></p>
<p>用 preorder 遍历一遍，递归的函数返回最后一个节点，这样可以把左右两个分支连接起来。</p>
<p>更简单的方法是用反向的 preorder，先探到末端，再从方法栈中一级级退出并连接之前的节点。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    TreeNode prev;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">flatten</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">flatten</span>(root.right);</span><br><span class="line">        <span class="keyword">flatten</span>(root.left);</span><br><span class="line">        root.right = prev;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>118. Pascal’s Triangle</strong></p>
<p><strong>119. Pascal’s Triangle II</strong></p>
<p>简单地迭代或递归。</p>
<p><strong>120. Triangle</strong></p>
<p>用递归的 DP 很简单，不过效率太低，很多重复计算。所以要改成迭代，我们从下向上计算，每次只需要保存前一行的结果，所以空间复杂度是 O(n)</p>
<p><strong>125. Valid Palindrome</strong></p>
<p>取头取尾，略过非字母或数字（用 Character.isLetterOrDigit 判断），迭代验证。比较简单。</p>
<p><strong>129. Sum Root to Leaf Numbers</strong></p>
<p>递归</p>
<p><strong>130. Surrounded Regions</strong></p>
<p>只有 O 连到边界上时，才不会被 X 包围，所以当遍历到边界上的 O 时，用 BFS 探索所有与之连接的 O，标记为 B。完事之后，再遍历一次，把 B 变成 O，O 变成 X。</p>
<p><strong>131. Palindrome Partitioning</strong></p>
<p>类似 DP，我们从头部开始在不同的地方做第一次切分，右半部分递归地继续切分，左半部分不用再切分，但必须保证是 Palindrome</p>
<p><strong>134. Gas Station</strong></p>
<p>本质上和 Maximum subarray problem 类似，见 121 和 53</p>
<p><strong>127. Word Ladder</strong></p>
<p>推荐，典型的 BFS</p>
<p><strong>133. Clone Graph</strong></p>
<p>DFS，可以用 map 缓存访问过的节点</p>
<p><strong>136. Single Number</strong></p>
<p>推荐，微软面试那本书上有，XOR 满足交换率，A ^ A = 0, A ^ 0 = A</p>
<p><strong>137. Single Number II</strong></p>
<p>推荐，这个题很精彩，用数字电路设计以及状态机的思路来解，整体思路就是设计个计数器</p>
<p><strong>260. Single Number III</strong></p>
<p>推荐。关键在于区分两个数</p>
<p><strong>139. Word Break</strong></p>
<p>DP 或分治，递归版本会超时，用迭代</p>
<p><strong>143. Reorder List</strong></p>
<p>一个技巧是用 walker 和 runner 去找中间点</p>
<p><strong>147. Insertion Sort List</strong></p>
<p>就是插入排序，从头开始一个个检查。</p>
<p><strong>148. Sort List</strong></p>
<p>推荐，List 版本的 Merge Sort</p>
<p><strong>153. Find Minimum in Rotated Sorted Array</strong></p>
<p>二分搜索</p>
<p><strong>155. Min Stack</strong></p>
<p>用偏差</p>
<p><strong>152. Maximum Product Subarray</strong></p>
<p>除了全局最大值，还需要记录局部最大值、最小值</p>
<p><strong>160. Intersection of Two Linked Lists</strong></p>
<p>一条遍历完之后就遍历另外一条，这样下一次就会在交点汇合</p>
<p><strong>165. Compare Version Numbers</strong></p>
<p>先 split，然后遍历，如果超过数组大小的，按 0 处理</p>
<p><strong>168. Excel Sheet Column Title</strong></p>
<p>注意并不是从 0 开始的</p>
<p><strong>172. Factorial Trailing Zeroes</strong></p>
<p>只有可能 2 * 5 才能得到 0，由于 2 的数量原大于 5，所以 0 的数量取决于 5 的数量，5 的数量计算公式为 n/5 + n/(5^2) + n/(5^3) + …</p>
<p><strong>173. Binary Search Tree Iterator</strong></p>
<p>用 stack 实现中序遍历，相当于是迭代版的中序遍历</p>
<p><strong>179. Largest Number</strong></p>
<p>定义一个 Comparator，用 Arrays.sort 来排序</p>
<p><strong>187. Repeated DNA Sequences</strong></p>
<p>用 tail substring 会超过限制 memory。可以用两个 set，一个存出现过的，一个存结果</p>
<p><strong>189. Rotate Array</strong></p>
<p>in-place 的一种做法是三次倒序。</p>
<p><strong>199. Binary Tree Right Side View</strong></p>
<p>BFS</p>
<p><strong>190. Reverse Bits</strong></p>
<p>先挪到最低位与 1 进行 AND 操作，再挪到正确的位置</p>
<p><strong>200. Number of Islands</strong></p>
<p>用 DFS，标记走过的路径</p>
<p><strong>201. Bitwise AND of Numbers Range</strong></p>
<p>如果两者不等，说明至少最后一位会被置零，然后两个数字</p>
<p><strong>203. Remove Linked List Elements</strong></p>
<p>很简单</p>
<p><strong>213. House Robber II</strong></p>
<p><strong>198. House Robber</strong></p>
<p>标准的 DP，注意要用迭代，不要用递归。迭代只需要保存前两项：include, exclude</p>
<p><strong>207. Course Schedule</strong></p>
<p><strong>210. Course Schedule II</strong></p>
<p>推荐。我用的是 DFS，也是 algorithm 红书上的算法。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; graph;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        Queue&lt;Integer&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">        onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">        graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">            graph.<span class="built_in">get</span>(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个循环是真正的 dfs 操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[i]) dfs(i, <span class="built_in">queue</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">queue</span>.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            result[i] = <span class="built_in">queue</span>.poll();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasCycle ? <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>] : result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, Queue&lt;Integer&gt; <span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">        onStack[v] = <span class="literal">true</span>;</span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : graph.<span class="built_in">get</span>(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasCycle) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onStack[i]) &#123;</span><br><span class="line">                hasCycle = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!marked[i]) &#123;</span><br><span class="line">                dfs(i, <span class="built_in">queue</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>.offer(v);</span><br><span class="line">        onStack[v] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>208. Implement Trie (Prefix Tree)</strong></p>
<p>标准的 Trie 树</p>
<p><strong>209. Minimum Size Subarray Sum</strong></p>
<p>两根指针，分别指头尾，一直维持范围最小</p>
<p><strong>205. Isomorphic Strings</strong></p>
<p>用一个数组存储最近一次出现该字母的位置</p>
<p><strong>211. Add and Search Word - Data structure design</strong></p>
<p>推荐，Trie 树的实现，用递归比较容易做，因为遇到 . 需要产生多个递归操作，如果迭代的话就需要使用一个队列了。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class WordDictionary &#123;</span><br><span class="line">    </span><br><span class="line">    private <span class="keyword">Node</span> <span class="title">root</span> = new <span class="keyword">Node</span><span class="title">();</span></span><br><span class="line"><span class="title">    </span></span><br><span class="line"><span class="title">    private</span> class <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">        boolean</span> hasWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">Node</span><span class="title">[] next</span> = new <span class="keyword">Node</span><span class="title">[26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Adds a word into the data structure.</span><br><span class="line">    public void addWord(<span class="keyword">String</span> word) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = root;</span><br><span class="line">        for (char c : word.toCharArray()) &#123;</span><br><span class="line">            int i = c - 'a';</span><br><span class="line">            if (<span class="keyword">node</span>.<span class="title">next</span>[i] == null) <span class="keyword">node</span>.<span class="title">next</span>[i] = new <span class="keyword">Node</span><span class="title">();</span></span><br><span class="line"><span class="title">            node</span> = <span class="keyword">node</span>.<span class="title">next</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">hasWord</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns if the word is <span class="keyword">in</span> the data structure. A word could</span><br><span class="line">    // contain the dot character '.' to represent any one letter.</span><br><span class="line">    public boolean search(<span class="keyword">String</span> word) &#123;</span><br><span class="line">        if (word == null || word.length() == <span class="number">0</span>) return <span class="literal">false</span>;</span><br><span class="line">        return search(word.toCharArray(), <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean search(char[] word, int <span class="literal">start</span>, <span class="keyword">Node</span> <span class="title">head</span>) &#123;</span><br><span class="line">        if (<span class="literal">start</span> == word.length) return head.hasWord;</span><br><span class="line">        char c = word[<span class="literal">start</span>];</span><br><span class="line">        if (c == '.') &#123;</span><br><span class="line">            for (<span class="keyword">Node</span> <span class="title">x</span> : head.next) &#123;</span><br><span class="line">                if (x != null &amp;&amp; search(word, <span class="literal">start</span> + <span class="number">1</span>, x)) return <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (head.next[c - 'a'] != null) &amp;&amp; search(word, <span class="literal">start</span> + <span class="number">1</span>, head.next[c - 'a']);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>215. Kth Largest Element in an Array</strong></p>
<p>推荐。这个是用 QuickSelect 算法，类似 QuickSort，细节需要好好处理，</p>
<p><strong>216. Combination Sum III</strong></p>
<p>bakctracking, 跟 dfs 类似，用一个 stack 来记录 path。</p>
<p><strong>219. Contains Duplicate II</strong></p>
<p>用 Map 或 Set 都可以，Set 更高效：把超出范围的删除，如果新增元素不成功，说明范围内有重复。</p>
<p><strong>220. Contains Duplicate III</strong></p>
<p>可以用 TreeSet，借助它的 ceiling, floor 方法，复杂度是 Nlgk。</p>
<p><strong>221. Maximal Square</strong></p>
<p>推荐。DP 的思路</p>
<p><strong>222. Count Complete Tree Nodes</strong></p>
<p>我们在递归暴力求解的基础上进行改进。用二分查找的思路（但不是真正的二分查找），我们检查最左和最右的深度，如果相等，说明是满的，这时可以直接返回整颗树的节点数目。</p>
<p><strong>223. Rectangle Area</strong></p>
<p>关键是 overlaping 区域的坐标计算。</p>
<p><strong>225. Implement Stack using Queues</strong></p>
<p><strong>232. Implement Queue using Stacks</strong></p>
<p>感觉这两题没啥意义，都只要改 push 方法：每次 push 都要借助另外一个容器把数据整体挪动一遍，目的是自行维护需要的数据结构。</p>
<p><strong>228. Summary Ranges</strong><br>不难，挨个检查就是了</p>
<p><strong>230. Kth Smallest Element in a BST</strong></p>
<p>in-order traversal, 等同于中序遍历</p>
<p><strong>234. Palindrome Linked List</strong></p>
<p>用 walker 和 runner 的技巧找出中间节点，然后把后半段反转，再从两端进行挨个比对。</p>
<p><strong>236. Lowest Common Ancestor of a Binary Tree</strong></p>
<p>推荐。我们一旦遇到 p 或者 q 就认为它是 LCA，然后将它向上传播，如果某个节点左右分支都有 LCA，说明它自己是真正的 LCA，如果只有一个分支有 LCA，那就返回那个分支的 LCA。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> lowestCommonAncestor(<span class="type">TreeNode</span> root, <span class="type">TreeNode</span> p, <span class="type">TreeNode</span> q) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">left</span> = lowestCommonAncestor(root.<span class="keyword">left</span>, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">right</span> = lowestCommonAncestor(root.<span class="keyword">right</span>, p, q);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">left</span> != null &amp;&amp; <span class="keyword">right</span> != null) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span> == null ? <span class="keyword">right</span> : <span class="keyword">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>238. Product of Array Except Self</strong></p>
<p>推荐。从左累积一遍，然后从右累积一遍，再把这两个数组相乘</p>
<p><strong>240. Search a 2D Matrix II</strong></p>
<p>用右上角的元素进行对比，每次可以消除一整行或者一整列。</p>
<p><strong>257. Binary Tree Paths</strong></p>
<p>推荐，DFS，path 可以不用 stack，用 String 每次都新建一个对象</p>
<p><strong>167. Two Sum II - Input array is sorted</strong></p>
<p>头尾两个指针</p>
<p><strong>241. Different Ways to Add Parentheses</strong></p>
<p>分治递归</p>
<p><strong>264. Ugly Number II</strong></p>
<p>挺精巧的</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   <span class="keyword"> public</span><span class="built_in"> int </span>nthUglyNumber(int n) &#123;</span><br><span class="line">       <span class="built_in"> if </span>(n == 1)<span class="built_in"> return </span>1;</span><br><span class="line">        int[] ugly =<span class="built_in"> new </span>int[n];</span><br><span class="line">        ugly[0] = 1;</span><br><span class="line">       <span class="built_in"> int </span>p2 = 0, p3 = 0, p5 = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            ugly[i] = Math.min(Math.min(2*ugly[p2], 3*ugly[p3]), 5*ugly[p5]);</span><br><span class="line">           <span class="built_in"> if </span>(ugly[i] == 2*ugly[p2]) p2++;</span><br><span class="line">           <span class="built_in"> if </span>(ugly[i] == 3*ugly[p3]) p3++;</span><br><span class="line">           <span class="built_in"> if </span>(ugly[i] == 5*ugly[p5]) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>ugly[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>268. Missing Number</strong></p>
<p>有 XOR 和 SUM 两种方法</p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/1465705199000/" rel="next" title="八皇后问题的 Clojure 和 JavaScript 解法">
                <i class="fa fa-chevron-left"></i> 八皇后问题的 Clojure 和 JavaScript 解法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/1467262787000/" rel="prev" title="Spring IoC 深入解析">
                Spring IoC 深入解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://live.staticflickr.com/7882/buddyicons/26146382@N07_r.jpg" alt="Yinyin Qian">
          <p class="site-author-name" itemprop="name">Yinyin Qian</p>
          <p class="site-description motion-element" itemprop="description">In me the tiger sniffs the rose</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">139</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://cn.linkedin.com/in/yyqian" target="_blank">
                  
                    <i class="fa fa-linkedin"></i>
                  
                  Linkedin
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/yyqian" target="_blank">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.flickr.com/photos/yyqian" target="_blank">
                  
                    <i class="fa fa-flickr"></i>
                  
                  Flickr
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#总结一些技巧和注意点"><span class="nav-text">总结一些技巧和注意点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意处理特殊情况"><span class="nav-text">注意处理特殊情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表问题的技巧"><span class="nav-text">列表问题的技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组问题"><span class="nav-text">数组问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字问题技巧"><span class="nav-text">数字问题技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见算法应用"><span class="nav-text">常见算法应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#技巧"><span class="nav-text">技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#各个题目的解题思路"><span class="nav-text">各个题目的解题思路</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2008 - 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yinyin Qian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  

  

</body>
</html>
